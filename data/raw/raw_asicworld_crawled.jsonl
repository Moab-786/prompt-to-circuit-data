{"url": "https://www.asic-world.com/code/tidbits/reg_seq_example.v", "filename": "reg_seq_example.v", "prompt": "Write Verilog code for Reg Seq Example.", "verilog_code": "module reg_seq_example( clk, reset, d, q);\ninput clk, reset, d;\noutput q;\n  \nreg   q;\nwire clk, reset, d;\n\nalways @ (posedge clk or posedge reset)\nif (reset) begin\n  q <= 1'b0;\nend else begin\n  q <= d;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/tidbits/reg_combo_example.v", "filename": "reg_combo_example.v", "prompt": "Write Verilog code for Reg Combo Example.", "verilog_code": "module reg_combo_example( a, b, y);\ninput a, b;\noutput y;\n\nreg   y;\nwire a, b;\n\nalways @ ( a or b)\nbegin\t\n  y = a & b;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/tidbits/asyn_reset.v", "filename": "asyn_reset.v", "prompt": "Write Verilog code for Asyn Reset.", "verilog_code": "module  asyn_reset(clk,reset,a,c);\n     input clk;\n     input reset;\n     input a;\n     output c; \n\n   wire clk;\n   wire reset;   \n   wire a;    \n   reg c;\n        \nalways @ (posedge clk or posedge reset)\n if ( reset == 1'b1) begin\n   c <= 0;\n end else begin\n   c <= a;\n end\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/tidbits/fsm_using_single_always.v", "filename": "fsm_using_single_always.v", "prompt": "Write Verilog code for Fsm Using Single Always.", "verilog_code": "//====================================================\n// This is FSM demo program using single always\n// for both seq and combo logic\n// Design Name : fsm_using_single_always\n// File Name   : fsm_using_single_always.v\n//=====================================================\nmodule fsm_using_single_always (\nclock      , // clock\nreset      , // Active high, syn reset\nreq_0      , // Request 0\nreq_1      , // Request 1\ngnt_0      , // Grant 0\ngnt_1      \n);\n//=============Input Ports=============================\ninput   clock,reset,req_0,req_1;\n //=============Output Ports===========================\noutput  gnt_0,gnt_1;\n//=============Input ports Data Type===================\nwire    clock,reset,req_0,req_1;\n//=============Output Ports Data Type==================\nreg     gnt_0,gnt_1;\n//=============Internal Constants======================\nparameter SIZE = 3           ;\nparameter IDLE  = 3'b001,GNT0 = 3'b010,GNT1 = 3'b100 ;\n//=============Internal Variables======================\nreg   [SIZE-1:0]          state        ;// Seq part of the FSM\nreg   [SIZE-1:0]          next_state   ;// combo part of FSM\n//==========Code startes Here==========================\nalways @ (posedge clock)\nbegin : FSM\nif (reset == 1'b1) begin\n  state <= #1 IDLE;\n  gnt_0 <= 0;\n  gnt_1 <= 0;\nend else\n case(state)\n   IDLE : if (req_0 == 1'b1) begin\n                state <= #1 GNT0;\n                gnt_0 <= 1;\n              end else if (req_1 == 1'b1) begin\n                gnt_1 <= 1;\n                state <= #1 GNT1;\n              end else begin\n                state <= #1 IDLE;\n              end\n   GNT0 : if (req_0 == 1'b1) begin\n                state <= #1 GNT0;\n              end else begin\n                gnt_0 <= 0;\n                state <= #1 IDLE;\n              end\n   GNT1 : if (req_1 == 1'b1) begin\n                state <= #1 GNT1;\n              end else begin\n                gnt_1 <= 0;\n                state <= #1 IDLE;\n              end\n   default : state <= #1 IDLE;\nendcase\nend\n\nendmodule // End of Module arbiter", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/tidbits/fsm_using_function.v", "filename": "fsm_using_function.v", "prompt": "Write Verilog code for Fsm Using Function.", "verilog_code": "//-----------------------------------------------------\n// This is FSM demo program using function\n// Design Name : fsm_using_function\n// File Name   : fsm_using_function.v\n//-----------------------------------------------------\nmodule fsm_using_function (\nclock      , // clock\nreset      , // Active high, syn reset\nreq_0      , // Request 0\nreq_1      , // Request 1\ngnt_0      , // Grant 0\ngnt_1      \n);\n//-------------Input Ports-----------------------------\ninput   clock,reset,req_0,req_1;\n //-------------Output Ports----------------------------\noutput  gnt_0,gnt_1;\n//-------------Input ports Data Type-------------------\nwire    clock,reset,req_0,req_1;\n//-------------Output Ports Data Type------------------\nreg     gnt_0,gnt_1;\n//-------------Internal Constants--------------------------\nparameter SIZE = 3           ;\nparameter IDLE  = 3'b001,GNT0 = 3'b010,GNT1 = 3'b100 ;\n//-------------Internal Variables---------------------------\nreg   [SIZE-1:0]          state        ;// Seq part of the FSM\nwire  [SIZE-1:0]          next_state   ;// combo part of FSM\n//----------Code startes Here------------------------\nassign next_state = fsm_function(state, req_0, req_1);\n//----------Function for Combo Logic-----------------\nfunction [SIZE-1:0] fsm_function;\n  input  [SIZE-1:0]  state ;\t\n  input    req_0 ;\n  input    req_1 ;\n  case(state)\n   IDLE : if (req_0 == 1'b1) begin\n                fsm_function = GNT0;\n              end else if (req_1 == 1'b1) begin\n                fsm_function= GNT1;\n              end else begin\n                fsm_function = IDLE;\n              end\n   GNT0 : if (req_0 == 1'b1) begin\n                fsm_function = GNT0;\n              end else begin\n                fsm_function = IDLE;\n              end\n   GNT1 : if (req_1 == 1'b1) begin\n                fsm_function = GNT1;\n          end else begin\n                fsm_function = IDLE;\n              end\n   default : fsm_function = IDLE;\n  endcase\nendfunction\n//----------Seq Logic-----------------------------\nalways @ (posedge clock)\nbegin : FSM_SEQ\n  if (reset == 1'b1) begin\n    state <= #1 IDLE;\n  end else begin\n    state <= #1 next_state;\n  end\nend\n//----------Output Logic-----------------------------\nalways @ (posedge clock)\nbegin : OUTPUT_LOGIC\nif (reset == 1'b1) begin\n  gnt_0 <= #1 1'b0;\n  gnt_1 <= #1 1'b0;\nend\nelse begin\n  case(state)\n    IDLE : begin\n                  gnt_0 <= #1 1'b0;\n                  gnt_1 <= #1 1'b0;\n               end\n   GNT0 : begin\n                   gnt_0 <= #1 1'b1;\n                   gnt_1 <= #1 1'b0;\n                end\n   GNT1 : begin\n                   gnt_0 <= #1 1'b0;\n                   gnt_1 <= #1 1'b1;\n                end\n   default : begin\n                    gnt_0 <= #1 1'b0;\n                    gnt_1 <= #1 1'b0;\n                  end\n  endcase\nend\nend // End Of Block OUTPUT_LOGIC\n\nendmodule // End of Module arbiter", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/tidbits/fsm_using_always.v", "filename": "fsm_using_always.v", "prompt": "Write Verilog code for Fsm Using Always.", "verilog_code": "//-----------------------------------------------------\n// This is FSM demo program using always block\n// Design Name : fsm_using_always\n// File Name   : fsm_using_always.v\n//-----------------------------------------------------\nmodule fsm_using_always (\nclock      , // clock\nreset      , // Active high, syn reset\nreq_0      , // Request 0\nreq_1      , // Request 1\ngnt_0      , // Grant 0\ngnt_1      \n);\n//-------------Input Ports-----------------------------\ninput   clock,reset,req_0,req_1;\n //-------------Output Ports----------------------------\noutput  gnt_0,gnt_1;\n//-------------Input ports Data Type-------------------\nwire    clock,reset,req_0,req_1;\n//-------------Output Ports Data Type------------------\nreg     gnt_0,gnt_1;\n//-------------Internal Constants--------------------------\nparameter SIZE = 3           ;\nparameter IDLE  = 3'b001,GNT0 = 3'b010,GNT1 = 3'b100 ;\n//-------------Internal Variables---------------------------\nreg   [SIZE-1:0]          state        ;// Seq part of the FSM\nreg   [SIZE-1:0]          next_state   ;// combo part of FSM\n//----------Code startes Here------------------------\nalways @ (state or req_0 or req_1)\nbegin : FSM_COMBO\n next_state = 3'b000;\n case(state)\n   IDLE : if (req_0 == 1'b1) begin\n                next_state = GNT0;\n              end else if (req_1 == 1'b1) begin\n                next_state= GNT1;\n              end else begin\n                next_state = IDLE;\n              end\n   GNT0 : if (req_0 == 1'b1) begin\n                next_state = GNT0;\n              end else begin\n                next_state = IDLE;\n              end\n   GNT1 : if (req_1 == 1'b1) begin\n                next_state = GNT1;\n              end else begin\n                next_state = IDLE;\n              end\n   default : next_state = IDLE;\n  endcase\nend\n//----------Seq Logic-----------------------------\nalways @ (posedge clock)\nbegin : FSM_SEQ\n  if (reset == 1'b1) begin\n    state <= #1 IDLE;\n  end else begin\n    state <= #1 next_state;\n  end\nend\n//----------Output Logic-----------------------------\nalways @ (posedge clock)\nbegin : OUTPUT_LOGIC\nif (reset == 1'b1) begin\n  gnt_0 <= #1 1'b0;\n  gnt_1 <= #1 1'b0;\nend\nelse begin\n  case(state)\n    IDLE : begin\n                  gnt_0 <= #1 1'b0;\n                  gnt_1 <= #1 1'b0;\n               end\n   GNT0 : begin\n                   gnt_0 <= #1 1'b1;\n                   gnt_1 <= #1 1'b0;\n                end\n   GNT1 : begin\n                   gnt_0 <= #1 1'b0;\n                   gnt_1 <= #1 1'b1;\n                end\n   default : begin\n                    gnt_0 <= #1 1'b0;\n                    gnt_1 <= #1 1'b0;\n                  end\n  endcase\nend\nend // End Of Block OUTPUT_LOGIC\n\nendmodule // End of Module arbiter", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/quest_for_out.v", "filename": "quest_for_out.v", "prompt": "Write Verilog code for Quest For Out.", "verilog_code": "module quest_for_out();\n\ninteger i;\nreg clk;\n\ninitial begin\n  clk = 0;\n  #4 $finish;\nend\n\nalways #1 clk = !clk;\n\nalways @ (posedge clk)\nbegin : FOR_OUT\n  for (i=0; i < 8; i = i + 1) begin\n    if (i == 5) begin\n      disable FOR_OUT;\n    end\n    $display (\"Current i : %g\",i);\n  end\nend\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/which_clock.v", "filename": "which_clock.v", "prompt": "Write Verilog code for Which Clock.", "verilog_code": "module which_clock (x,y,q,d);\ninput x,y,d;\noutput q;\nreg q;\n\nalways @ (posedge x or posedge y)\n   if (x) \n     q <= 1'b0;\n   else\n     q <= d;\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/quest_for_in.v", "filename": "quest_for_in.v", "prompt": "Write Verilog code for Quest For In.", "verilog_code": "module quest_for_in();\n\ninteger i;\nreg clk;\n\ninitial begin\n  clk = 0;\n  #4 $finish;\nend\n\nalways #1 clk = !clk;\n\nalways @ (posedge clk)\nbegin\n  for (i=0; i < 8; i = i + 1) begin : FOR_IN\n    if (i == 5) begin\n      disable FOR_IN;\n    end\n    $display (\"Current i : %g\",i);\n  end\nend\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/which_clock.v", "filename": "which_clock.v", "prompt": "Write Verilog code for Which Clock.", "verilog_code": "module which_clock (x,y,q,d);\ninput x,y,d;\noutput q;\nreg q;\n\nalways @ (posedge x or posedge y)\n   if (x) \n     q <= 1'b0;\n   else\n     q <= d;\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/quest_for_in.v", "filename": "quest_for_in.v", "prompt": "Write Verilog code for Quest For In.", "verilog_code": "module quest_for_in();\n\ninteger i;\nreg clk;\n\ninitial begin\n  clk = 0;\n  #4 $finish;\nend\n\nalways #1 clk = !clk;\n\nalways @ (posedge clk)\nbegin\n  for (i=0; i < 8; i = i + 1) begin : FOR_IN\n    if (i == 5) begin\n      disable FOR_IN;\n    end\n    $display (\"Current i : %g\",i);\n  end\nend\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/quest_for_out.v", "filename": "quest_for_out.v", "prompt": "Write Verilog code for Quest For Out.", "verilog_code": "module quest_for_out();\n\ninteger i;\nreg clk;\n\ninitial begin\n  clk = 0;\n  #4 $finish;\nend\n\nalways #1 clk = !clk;\n\nalways @ (posedge clk)\nbegin : FOR_OUT\n  for (i=0; i < 8; i = i + 1) begin\n    if (i == 5) begin\n      disable FOR_OUT;\n    end\n    $display (\"Current i : %g\",i);\n  end\nend\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/tidbits/fsm_using_single_always.v", "filename": "fsm_using_single_always.v", "prompt": "Write Verilog code for Fsm Using Single Always.", "verilog_code": "//====================================================\n// This is FSM demo program using single always\n// for both seq and combo logic\n// Design Name : fsm_using_single_always\n// File Name   : fsm_using_single_always.v\n//=====================================================\nmodule fsm_using_single_always (\nclock      , // clock\nreset      , // Active high, syn reset\nreq_0      , // Request 0\nreq_1      , // Request 1\ngnt_0      , // Grant 0\ngnt_1      \n);\n//=============Input Ports=============================\ninput   clock,reset,req_0,req_1;\n //=============Output Ports===========================\noutput  gnt_0,gnt_1;\n//=============Input ports Data Type===================\nwire    clock,reset,req_0,req_1;\n//=============Output Ports Data Type==================\nreg     gnt_0,gnt_1;\n//=============Internal Constants======================\nparameter SIZE = 3           ;\nparameter IDLE  = 3'b001,GNT0 = 3'b010,GNT1 = 3'b100 ;\n//=============Internal Variables======================\nreg   [SIZE-1:0]          state        ;// Seq part of the FSM\nreg   [SIZE-1:0]          next_state   ;// combo part of FSM\n//==========Code startes Here==========================\nalways @ (posedge clock)\nbegin : FSM\nif (reset == 1'b1) begin\n  state <= #1 IDLE;\n  gnt_0 <= 0;\n  gnt_1 <= 0;\nend else\n case(state)\n   IDLE : if (req_0 == 1'b1) begin\n                state <= #1 GNT0;\n                gnt_0 <= 1;\n              end else if (req_1 == 1'b1) begin\n                gnt_1 <= 1;\n                state <= #1 GNT1;\n              end else begin\n                state <= #1 IDLE;\n              end\n   GNT0 : if (req_0 == 1'b1) begin\n                state <= #1 GNT0;\n              end else begin\n                gnt_0 <= 0;\n                state <= #1 IDLE;\n              end\n   GNT1 : if (req_1 == 1'b1) begin\n                state <= #1 GNT1;\n              end else begin\n                gnt_1 <= 0;\n                state <= #1 IDLE;\n              end\n   default : state <= #1 IDLE;\nendcase\nend\n\nendmodule // End of Module arbiter", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/tidbits/fsm_using_always.v", "filename": "fsm_using_always.v", "prompt": "Write Verilog code for Fsm Using Always.", "verilog_code": "//-----------------------------------------------------\n// This is FSM demo program using always block\n// Design Name : fsm_using_always\n// File Name   : fsm_using_always.v\n//-----------------------------------------------------\nmodule fsm_using_always (\nclock      , // clock\nreset      , // Active high, syn reset\nreq_0      , // Request 0\nreq_1      , // Request 1\ngnt_0      , // Grant 0\ngnt_1      \n);\n//-------------Input Ports-----------------------------\ninput   clock,reset,req_0,req_1;\n //-------------Output Ports----------------------------\noutput  gnt_0,gnt_1;\n//-------------Input ports Data Type-------------------\nwire    clock,reset,req_0,req_1;\n//-------------Output Ports Data Type------------------\nreg     gnt_0,gnt_1;\n//-------------Internal Constants--------------------------\nparameter SIZE = 3           ;\nparameter IDLE  = 3'b001,GNT0 = 3'b010,GNT1 = 3'b100 ;\n//-------------Internal Variables---------------------------\nreg   [SIZE-1:0]          state        ;// Seq part of the FSM\nreg   [SIZE-1:0]          next_state   ;// combo part of FSM\n//----------Code startes Here------------------------\nalways @ (state or req_0 or req_1)\nbegin : FSM_COMBO\n next_state = 3'b000;\n case(state)\n   IDLE : if (req_0 == 1'b1) begin\n                next_state = GNT0;\n              end else if (req_1 == 1'b1) begin\n                next_state= GNT1;\n              end else begin\n                next_state = IDLE;\n              end\n   GNT0 : if (req_0 == 1'b1) begin\n                next_state = GNT0;\n              end else begin\n                next_state = IDLE;\n              end\n   GNT1 : if (req_1 == 1'b1) begin\n                next_state = GNT1;\n              end else begin\n                next_state = IDLE;\n              end\n   default : next_state = IDLE;\n  endcase\nend\n//----------Seq Logic-----------------------------\nalways @ (posedge clock)\nbegin : FSM_SEQ\n  if (reset == 1'b1) begin\n    state <= #1 IDLE;\n  end else begin\n    state <= #1 next_state;\n  end\nend\n//----------Output Logic-----------------------------\nalways @ (posedge clock)\nbegin : OUTPUT_LOGIC\nif (reset == 1'b1) begin\n  gnt_0 <= #1 1'b0;\n  gnt_1 <= #1 1'b0;\nend\nelse begin\n  case(state)\n    IDLE : begin\n                  gnt_0 <= #1 1'b0;\n                  gnt_1 <= #1 1'b0;\n               end\n   GNT0 : begin\n                   gnt_0 <= #1 1'b1;\n                   gnt_1 <= #1 1'b0;\n                end\n   GNT1 : begin\n                   gnt_0 <= #1 1'b0;\n                   gnt_1 <= #1 1'b1;\n                end\n   default : begin\n                    gnt_0 <= #1 1'b0;\n                    gnt_1 <= #1 1'b0;\n                  end\n  endcase\nend\nend // End Of Block OUTPUT_LOGIC\n\nendmodule // End of Module arbiter", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/tidbits/fsm_using_function.v", "filename": "fsm_using_function.v", "prompt": "Write Verilog code for Fsm Using Function.", "verilog_code": "//-----------------------------------------------------\n// This is FSM demo program using function\n// Design Name : fsm_using_function\n// File Name   : fsm_using_function.v\n//-----------------------------------------------------\nmodule fsm_using_function (\nclock      , // clock\nreset      , // Active high, syn reset\nreq_0      , // Request 0\nreq_1      , // Request 1\ngnt_0      , // Grant 0\ngnt_1      \n);\n//-------------Input Ports-----------------------------\ninput   clock,reset,req_0,req_1;\n //-------------Output Ports----------------------------\noutput  gnt_0,gnt_1;\n//-------------Input ports Data Type-------------------\nwire    clock,reset,req_0,req_1;\n//-------------Output Ports Data Type------------------\nreg     gnt_0,gnt_1;\n//-------------Internal Constants--------------------------\nparameter SIZE = 3           ;\nparameter IDLE  = 3'b001,GNT0 = 3'b010,GNT1 = 3'b100 ;\n//-------------Internal Variables---------------------------\nreg   [SIZE-1:0]          state        ;// Seq part of the FSM\nwire  [SIZE-1:0]          next_state   ;// combo part of FSM\n//----------Code startes Here------------------------\nassign next_state = fsm_function(state, req_0, req_1);\n//----------Function for Combo Logic-----------------\nfunction [SIZE-1:0] fsm_function;\n  input  [SIZE-1:0]  state ;\t\n  input    req_0 ;\n  input    req_1 ;\n  case(state)\n   IDLE : if (req_0 == 1'b1) begin\n                fsm_function = GNT0;\n              end else if (req_1 == 1'b1) begin\n                fsm_function= GNT1;\n              end else begin\n                fsm_function = IDLE;\n              end\n   GNT0 : if (req_0 == 1'b1) begin\n                fsm_function = GNT0;\n              end else begin\n                fsm_function = IDLE;\n              end\n   GNT1 : if (req_1 == 1'b1) begin\n                fsm_function = GNT1;\n          end else begin\n                fsm_function = IDLE;\n              end\n   default : fsm_function = IDLE;\n  endcase\nendfunction\n//----------Seq Logic-----------------------------\nalways @ (posedge clock)\nbegin : FSM_SEQ\n  if (reset == 1'b1) begin\n    state <= #1 IDLE;\n  end else begin\n    state <= #1 next_state;\n  end\nend\n//----------Output Logic-----------------------------\nalways @ (posedge clock)\nbegin : OUTPUT_LOGIC\nif (reset == 1'b1) begin\n  gnt_0 <= #1 1'b0;\n  gnt_1 <= #1 1'b0;\nend\nelse begin\n  case(state)\n    IDLE : begin\n                  gnt_0 <= #1 1'b0;\n                  gnt_1 <= #1 1'b0;\n               end\n   GNT0 : begin\n                   gnt_0 <= #1 1'b1;\n                   gnt_1 <= #1 1'b0;\n                end\n   GNT1 : begin\n                   gnt_0 <= #1 1'b0;\n                   gnt_1 <= #1 1'b1;\n                end\n   default : begin\n                    gnt_0 <= #1 1'b0;\n                    gnt_1 <= #1 1'b0;\n                  end\n  endcase\nend\nend // End Of Block OUTPUT_LOGIC\n\nendmodule // End of Module arbiter", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/tidbits/reg_combo_example.v", "filename": "reg_combo_example.v", "prompt": "Write Verilog code for Reg Combo Example.", "verilog_code": "module reg_combo_example( a, b, y);\ninput a, b;\noutput y;\n\nreg   y;\nwire a, b;\n\nalways @ ( a or b)\nbegin\t\n  y = a & b;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/tidbits/reg_seq_example.v", "filename": "reg_seq_example.v", "prompt": "Write Verilog code for Reg Seq Example.", "verilog_code": "module reg_seq_example( clk, reset, d, q);\ninput clk, reset, d;\noutput q;\n  \nreg   q;\nwire clk, reset, d;\n\nalways @ (posedge clk or posedge reset)\nif (reset) begin\n  q <= 1'b0;\nend else begin\n  q <= d;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/tidbits/asyn_reset.v", "filename": "asyn_reset.v", "prompt": "Write Verilog code for Asyn Reset.", "verilog_code": "module  asyn_reset(clk,reset,a,c);\n     input clk;\n     input reset;\n     input a;\n     output c; \n\n   wire clk;\n   wire reset;   \n   wire a;    \n   reg c;\n        \nalways @ (posedge clk or posedge reset)\n if ( reset == 1'b1) begin\n   c <= 0;\n end else begin\n   c <= a;\n end\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/uart.v", "filename": "uart.v", "prompt": "Write Verilog code for Uart.", "verilog_code": "//-----------------------------------------------------\n// Design Name : uart \n// File Name   : uart.v\n// Function    : Simple UART\n// Coder       : Deepak Kumar Tala\n//-----------------------------------------------------\nmodule uart (\nreset          ,\ntxclk          ,\nld_tx_data     ,\ntx_data        ,\ntx_enable      ,\ntx_out         ,\ntx_empty       ,\nrxclk          ,\nuld_rx_data    ,\nrx_data        ,\nrx_enable      ,\nrx_in          ,\nrx_empty\n);\n// Port declarations\ninput        reset          ;\ninput        txclk          ;\ninput        ld_tx_data     ;\ninput  [7:0] tx_data        ;\ninput        tx_enable      ;\noutput       tx_out         ;\noutput       tx_empty       ;\ninput        rxclk          ;\ninput        uld_rx_data    ;\noutput [7:0] rx_data        ;\ninput        rx_enable      ;\ninput        rx_in          ;\noutput       rx_empty       ;\n\n// Internal Variables \nreg [7:0]    tx_reg         ;\nreg          tx_empty       ;\nreg          tx_over_run    ;\nreg [3:0]    tx_cnt         ;\nreg          tx_out         ;\nreg [7:0]    rx_reg         ;\nreg [7:0]    rx_data        ;\nreg [3:0]    rx_sample_cnt  ;\nreg [3:0]    rx_cnt         ;  \nreg          rx_frame_err   ;\nreg          rx_over_run    ;\nreg          rx_empty       ;\nreg          rx_d1          ;\nreg          rx_d2          ;\nreg          rx_busy        ;\n\n// UART RX Logic\nalways @ (posedge rxclk or posedge reset)\nif (reset) begin\n  rx_reg        <= 0; \n  rx_data       <= 0;\n  rx_sample_cnt <= 0;\n  rx_cnt        <= 0;\n  rx_frame_err  <= 0;\n  rx_over_run   <= 0;\n  rx_empty      <= 1;\n  rx_d1         <= 1;\n  rx_d2         <= 1;\n  rx_busy       <= 0;\nend else begin\n  // Synchronize the asynch signal\n  rx_d1 <= rx_in;\n  rx_d2 <= rx_d1;\n  // Uload the rx data\n  if (uld_rx_data) begin\n    rx_data  <= rx_reg;\n    rx_empty <= 1;\n  end\n  // Receive data only when rx is enabled\n  if (rx_enable) begin\n    // Check if just received start of frame\n    if (!rx_busy && !rx_d2) begin\n      rx_busy       <= 1;\n      rx_sample_cnt <= 1;\n      rx_cnt        <= 0;\n    end\n    // Start of frame detected, Proceed with rest of data\n    if (rx_busy) begin\n       rx_sample_cnt <= rx_sample_cnt + 1;\n       // Logic to sample at middle of data\n       if (rx_sample_cnt == 7) begin\n          if ((rx_d2 == 1) && (rx_cnt == 0)) begin\n            rx_busy <= 0;\n          end else begin\n            rx_cnt <= rx_cnt + 1; \n            // Start storing the rx data\n            if (rx_cnt > 0 && rx_cnt < 9) begin\n              rx_reg[rx_cnt - 1] <= rx_d2;\n            end\n            if (rx_cnt == 9) begin\n               rx_busy <= 0;\n               // Check if End of frame received correctly\n               if (rx_d2 == 0) begin\n                 rx_frame_err <= 1;\n               end else begin\n                 rx_empty     <= 0;\n                 rx_frame_err <= 0;\n                 // Check if last rx data was not unloaded,\n                 rx_over_run  <= (rx_empty) ? 0 : 1;\n               end\n            end\n          end\n       end \n    end \n  end\n  if (!rx_enable) begin\n    rx_busy <= 0;\n  end\nend\n\n// UART TX Logic\nalways @ (posedge txclk or posedge reset)\nif (reset) begin\n  tx_reg        <= 0;\n  tx_empty      <= 1;\n  tx_over_run   <= 0;\n  tx_out        <= 1;\n  tx_cnt        <= 0;\nend else begin\n   if (ld_tx_data) begin\n      if (!tx_empty) begin\n        tx_over_run <= 0;\n      end else begin\n        tx_reg   <= tx_data;\n        tx_empty <= 0;\n      end\n   end\n   if (tx_enable && !tx_empty) begin\n     tx_cnt <= tx_cnt + 1;\n     if (tx_cnt == 0) begin\n       tx_out <= 0;\n     end\n     if (tx_cnt > 0 && tx_cnt < 9) begin\n        tx_out <= tx_reg[tx_cnt -1];\n     end\n     if (tx_cnt == 9) begin\n       tx_out <= 1;\n       tx_cnt <= 0;\n       tx_empty <= 1;\n     end\n   end\n   if (!tx_enable) begin\n     tx_cnt <= 0;\n   end\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/arbiter.v", "filename": "arbiter.v", "prompt": "Write Verilog code for Arbiter.", "verilog_code": "//----------------------------------------------------\r\n// A four level, round-robin arbiter. This was\r\n// orginally coded by WD Peterson in VHDL.\r\n//----------------------------------------------------\r\nmodule arbiter (\r\n  clk,    \r\n  rst,    \r\n  req3,   \r\n  req2,   \r\n  req1,   \r\n  req0,   \r\n  gnt3,   \r\n  gnt2,   \r\n  gnt1,   \r\n  gnt0   \r\n);\r\n// --------------Port Declaration----------------------- \r\ninput           clk;    \r\ninput           rst;    \r\ninput           req3;   \r\ninput           req2;   \r\ninput           req1;   \r\ninput           req0;   \r\noutput          gnt3;   \r\noutput          gnt2;   \r\noutput          gnt1;   \r\noutput          gnt0;   \r\n\r\n//--------------Internal Registers----------------------\r\nwire    [1:0]   gnt       ;   \r\nwire            comreq    ; \r\nwire            beg       ;\r\nwire   [1:0]    lgnt      ;\r\nwire            lcomreq   ;\r\nreg             lgnt0     ;\r\nreg             lgnt1     ;\r\nreg             lgnt2     ;\r\nreg             lgnt3     ;\r\nreg             lasmask   ;\r\nreg             lmask0    ;\r\nreg             lmask1    ;\r\nreg             ledge     ;\r\n\r\n//--------------Code Starts Here----------------------- \r\nalways @ (posedge clk)\r\nif (rst) begin\r\n  lgnt0 <= 0;\r\n  lgnt1 <= 0;\r\n  lgnt2 <= 0;\r\n  lgnt3 <= 0;\r\nend else begin                                     \r\n  lgnt0 <=(~lcomreq & ~lmask1 & ~lmask0 & ~req3 & ~req2 & ~req1 & req0)\r\n        | (~lcomreq & ~lmask1 &  lmask0 & ~req3 & ~req2 &  req0)\r\n        | (~lcomreq &  lmask1 & ~lmask0 & ~req3 &  req0)\r\n        | (~lcomreq &  lmask1 &  lmask0 & req0  )\r\n        | ( lcomreq & lgnt0 );\r\n  lgnt1 <=(~lcomreq & ~lmask1 & ~lmask0 &  req1)\r\n        | (~lcomreq & ~lmask1 &  lmask0 & ~req3 & ~req2 &  req1 & ~req0)\r\n        | (~lcomreq &  lmask1 & ~lmask0 & ~req3 &  req1 & ~req0)\r\n        | (~lcomreq &  lmask1 &  lmask0 &  req1 & ~req0)\r\n        | ( lcomreq &  lgnt1);\r\n  lgnt2 <=(~lcomreq & ~lmask1 & ~lmask0 &  req2  & ~req1)\r\n        | (~lcomreq & ~lmask1 &  lmask0 &  req2)\r\n        | (~lcomreq &  lmask1 & ~lmask0 & ~req3 &  req2  & ~req1 & ~req0)\r\n        | (~lcomreq &  lmask1 &  lmask0 &  req2 & ~req1 & ~req0)\r\n        | ( lcomreq &  lgnt2);\r\n  lgnt3 <=(~lcomreq & ~lmask1 & ~lmask0 & req3  & ~req2 & ~req1)\r\n        | (~lcomreq & ~lmask1 &  lmask0 & req3  & ~req2)\r\n        | (~lcomreq &  lmask1 & ~lmask0 & req3)\r\n        | (~lcomreq &  lmask1 &  lmask0 & req3  & ~req2 & ~req1 & ~req0)\r\n        | ( lcomreq & lgnt3);\r\nend \r\n\r\n//----------------------------------------------------\r\n// lasmask state machine.\r\n//----------------------------------------------------\r\nassign beg = (req3 | req2 | req1 | req0) & ~lcomreq;\r\nalways @ (posedge clk)\r\nbegin                                     \r\n  lasmask <= (beg & ~ledge & ~lasmask);\r\n  ledge   <= (beg & ~ledge &  lasmask) \r\n          |  (beg &  ledge & ~lasmask);\r\nend \r\n\r\n//----------------------------------------------------\r\n// comreq logic.\r\n//----------------------------------------------------\r\nassign lcomreq = ( req3 & lgnt3 )\r\n                | ( req2 & lgnt2 )\r\n                | ( req1 & lgnt1 )\r\n                | ( req0 & lgnt0 );\r\n\r\n//----------------------------------------------------\r\n// Encoder logic.\r\n//----------------------------------------------------\r\nassign  lgnt =  {(lgnt3 | lgnt2),(lgnt3 | lgnt1)};\r\n\r\n//----------------------------------------------------\r\n// lmask register.\r\n//----------------------------------------------------\r\nalways @ (posedge clk )\r\nif( rst ) begin\r\n  lmask1 <= 0;\r\n  lmask0 <= 0;\r\nend else if(lasmask) begin\r\n  lmask1 <= lgnt[1];\r\n  lmask0 <= lgnt[0];\r\nend else begin\r\n  lmask1 <= lmask1;\r\n  lmask0 <= lmask0;\r\nend \r\n\r\nassign comreq = lcomreq;\r\nassign gnt    = lgnt;\r\n//----------------------------------------------------\r\n// Drive the outputs\r\n//----------------------------------------------------\r\nassign gnt3   = lgnt3;\r\nassign gnt2   = lgnt2;\r\nassign gnt1   = lgnt1;\r\nassign gnt0   = lgnt0;\r\n\r\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/mux_using_if.v", "filename": "mux_using_if.v", "prompt": "Write Verilog code for Mux Using If.", "verilog_code": "//-----------------------------------------------------\n// Design Name : mux_using_if\n// File Name   : mux_using_if.v\n// Function    : 2:1 Mux using If\n// Coder       : Deepak Kumar Tala\n//-----------------------------------------------------\nmodule  mux_using_if(\ndin_0      , // Mux first input\ndin_1      , // Mux Second input\nsel        , // Select input\nmux_out      // Mux output\n);\n//-----------Input Ports---------------\ninput din_0, din_1, sel ;\n//-----------Output Ports---------------\noutput mux_out;\n//------------Internal Variables--------\nreg  mux_out;\n//-------------Code Starts Here---------\nalways @ (sel or din_0 or din_1)\nbegin : MUX\n  if (sel == 1'b0) begin\n      mux_out = din_0;\n  end else begin\n      mux_out = din_1 ;\n  end\nend\n\nendmodule //End Of Module mux", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/mux_using_case.v", "filename": "mux_using_case.v", "prompt": "Write Verilog code for Mux Using Case.", "verilog_code": "//-----------------------------------------------------\n// Design Name : mux_using_case\n// File Name   : mux_using_case.v\n// Function    : 2:1 Mux using Case\n// Coder       : Deepak Kumar Tala\n//-----------------------------------------------------\nmodule  mux_using_case(\ndin_0      , // Mux first input\ndin_1      , // Mux Second input\nsel           , // Select input\nmux_out   // Mux output\n);\n//-----------Input Ports---------------\ninput din_0, din_1, sel ;\n//-----------Output Ports---------------\noutput mux_out;\n//------------Internal Variables--------\nreg  mux_out;\n//-------------Code Starts Here---------\nalways @ (sel or din_0 or din_1)\nbegin : MUX\n case(sel ) \n    1'b0 : mux_out = din_0;\n    1'b1 : mux_out = din_1;\n endcase \nend\n\nendmodule //End Of Module mux", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/mux_using_assign.v", "filename": "mux_using_assign.v", "prompt": "Write Verilog code for Mux Using Assign.", "verilog_code": "//-----------------------------------------------------\n// Design Name : mux_using_assign\n// File Name   : mux_using_assign.v\n// Function    : 2:1 Mux using Assign\n// Coder       : Deepak Kumar Tala\n//-----------------------------------------------------\nmodule  mux_using_assign(\ndin_0      , // Mux first input\ndin_1      , // Mux Second input\nsel        , // Select input\nmux_out      // Mux output\n);\n//-----------Input Ports---------------\ninput din_0, din_1, sel ;\n//-----------Output Ports---------------\noutput mux_out;\n//------------Internal Variables--------\nwire  mux_out;\n//-------------Code Start-----------------\nassign mux_out = (sel) ? din_1 : din_0;\n\nendmodule //End Of Module mux", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/first_counter.v", "filename": "first_counter.v", "prompt": "Write Verilog code for First Counter.", "verilog_code": "//-----------------------------------------------------\n// This is my second Verilog Design\n// Design Name : first_counter\n// File Name : first_counter.v\n// Function : This is a 4 bit up-counter with\n// Synchronous active high reset and\n// with active high enable signal\n//-----------------------------------------------------\nmodule first_counter (\nclock , // Clock input of the design\nreset , // active high, synchronous Reset input\nenable , // Active high enable signal for counter\ncounter_out // 4 bit vector output of the counter\n); // End of port list\n//-------------Input Ports-----------------------------\ninput clock ;\ninput reset ;\ninput enable ;\n//-------------Output Ports----------------------------\noutput [3:0] counter_out ;\n//-------------Input ports Data Type-------------------\n// By rule all the input ports should be wires   \nwire clock ;\nwire reset ;\nwire enable ;\n//-------------Output Ports Data Type------------------\n// Output port can be a storage element (reg) or a wire\nreg [3:0] counter_out ;\n\n//------------Code Starts Here-------------------------\n// Since this counter is a positive edge trigged one,\n// We trigger the below block with respect to positive\n// edge of the clock.\nalways @ (posedge clock)\nbegin : COUNTER // Block Name\n  // At every rising edge of clock we check if reset is active\n  // If active, we load the counter output with 4'b0000\n  if (reset == 1'b1) begin\n    counter_out <= #1 4'b0000;\n  end\n  // If enable is active, then we increment the counter\n  else if (enable == 1'b1) begin\n    counter_out <= #1 counter_out + 1;\n  end\nend // End of Block COUNTER\n\nendmodule // End of Module counter", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/hello_world.v", "filename": "hello_world.v", "prompt": "Write Verilog code for Hello World.", "verilog_code": "//-----------------------------------------------------\n// This is my first Verilog Program\n// Design Name : hello_world\n// File Name : hello_world.v\n// Function : This program will print 'hello world'\n// Coder    : Deepak\n//-----------------------------------------------------\nmodule hello_world ;\n\ninitial begin\n  $display (\"Hello World by Deepak\");\n  #10 $finish;\nend\n\nendmodule // End of Module hello_world", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/unique_names.v", "filename": "unique_names.v", "prompt": "Write Verilog code for Unique Names.", "verilog_code": "input                    // a Verilog Keyword\nwire                     // a Verilog Keyword\nWIRE                  // a unique name ( not a keyword)\nWire                    // a unique name (not a keyword)", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/param_more_then_one1.v", "filename": "param_more_then_one1.v", "prompt": "Write Verilog code for Param More Then One1.", "verilog_code": "module  ram_controller ();//Some ports\n\n// Controller Code\n \nram_sp_sr_sw #(16,8,256)  ram(clk,address,data,cs,we,oe);\n \nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/param_more_then_one2.v", "filename": "param_more_then_one2.v", "prompt": "Write Verilog code for Param More Then One2.", "verilog_code": "module  ram_controller ();//Some ports\n \nram_sp_sr_sw #( \n\t.DATA_WIDTH(16), \n\t.ADDR_WIDTH(8), \n\t.RAM_DEPTH(256))  ram(clk,address,data,cs,we,oe);\n \nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/param_more_then_one.v", "filename": "param_more_then_one.v", "prompt": "Write Verilog code for Param More Then One.", "verilog_code": "module  ram_sp_sr_sw ( \nclk         , // Clock Input\naddress     , // Address Input\ndata        , // Data bi-directional\ncs          , // Chip Select\nwe          , // Write Enable/Read Enable\noe            // Output Enable\n); \n\nparameter DATA_WIDTH = 8 ;\nparameter ADDR_WIDTH = 8 ;\nparameter RAM_DEPTH = 1 << ADDR_WIDTH;\n// Actual code of RAM here\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/fsm_combo.v", "filename": "fsm_combo.v", "prompt": "Write Verilog code for Fsm Combo.", "verilog_code": "always @ (state or req_0 or req_1 or req_2 or req_3)\nbegin       \n  next_state = 0;\n  case(state)\n    IDLE : if (req_0 == 1'b1) begin\n  \t     next_state = GNT0;\n           end else if (req_1 == 1'b1) begin\n  \t     next_state= GNT1;\n           end else if (req_2 == 1'b1) begin\n  \t     next_state= GNT2;\n           end else if (req_3 == 1'b1) begin\n  \t     next_state= GNT3;\n\t   end else begin\n  \t     next_state = IDLE;\n           end\t\t\t\n    GNT0 : if (req_0 == 1'b0) begin\n  \t     next_state = IDLE;\n           end else begin\n\t     next_state = GNT0;\n\t  end\n    GNT1 : if (req_1 == 1'b0) begin\n  \t     next_state = IDLE;\n           end else begin\n\t     next_state = GNT1;\n\t  end\n    GNT2 : if (req_2 == 1'b0) begin\n  \t     next_state = IDLE;\n           end else begin\n\t     next_state = GNT2;\n\t  end\n    GNT3 : if (req_3 == 1'b0) begin\n  \t     next_state = IDLE;\n           end else begin\n\t     next_state = GNT3;\n\t  end\n   default : next_state = IDLE;\n  endcase\nend", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/fsm_full.v", "filename": "fsm_full.v", "prompt": "Write Verilog code for Fsm Full.", "verilog_code": "module fsm_full(\nclock , // Clock\nreset , // Active high reset\nreq_0 , // Active high request from agent 0\nreq_1 , // Active high request from agent 1\nreq_2 , // Active high request from agent 2\nreq_3 , // Active high request from agent 3\ngnt_0 , // Active high grant to agent 0\ngnt_1 , // Active high grant to agent 1\ngnt_2 , // Active high grant to agent 2\ngnt_3   // Active high grant to agent 3\n);\n// Port declaration here\ninput clock ; // Clock\ninput reset ; // Active high reset\ninput req_0 ; // Active high request from agent 0\ninput req_1 ; // Active high request from agent 1\ninput req_2 ; // Active high request from agent 2\ninput req_3 ; // Active high request from agent 3\noutput gnt_0 ; // Active high grant to agent 0\noutput gnt_1 ; // Active high grant to agent 1\noutput gnt_2 ; // Active high grant to agent 2\noutput gnt_3 ; // Active high grant to agent \n\n// Internal Variables\nreg    gnt_0 ; // Active high grant to agent 0\nreg    gnt_1 ; // Active high grant to agent 1\nreg    gnt_2 ; // Active high grant to agent 2\nreg    gnt_3 ; // Active high grant to agent \n\nparameter  [2:0]  IDLE  = 3'b000;\nparameter  [2:0]  GNT0  = 3'b001;\nparameter  [2:0]  GNT1  = 3'b010;\nparameter  [2:0]  GNT2  = 3'b011;\nparameter  [2:0]  GNT3  = 3'b100;\n\nreg [2:0] state, next_state;\n\nalways @ (state or req_0 or req_1 or req_2 or req_3)\nbegin  \n  next_state = 0;\n  case(state)\n    IDLE : if (req_0 == 1'b1) begin\n  \t     next_state = GNT0;\n           end else if (req_1 == 1'b1) begin\n  \t     next_state= GNT1;\n           end else if (req_2 == 1'b1) begin\n  \t     next_state= GNT2;\n           end else if (req_3 == 1'b1) begin\n  \t     next_state= GNT3;\n\t   end else begin\n  \t     next_state = IDLE;\n           end\t\t\t\n    GNT0 : if (req_0 == 1'b0) begin\n  \t     next_state = IDLE;\n           end else begin\n\t     next_state = GNT0;\n\t  end\n    GNT1 : if (req_1 == 1'b0) begin\n  \t     next_state = IDLE;\n           end else begin\n\t     next_state = GNT1;\n\t  end\n    GNT2 : if (req_2 == 1'b0) begin\n  \t     next_state = IDLE;\n           end else begin\n\t     next_state = GNT2;\n\t  end\n    GNT3 : if (req_3 == 1'b0) begin\n  \t     next_state = IDLE;\n           end else begin\n\t     next_state = GNT3;\n\t  end\n   default : next_state = IDLE;\n  endcase\nend\n\nalways @ (posedge clock)\nbegin : OUTPUT_LOGIC\n  if (reset) begin\n    gnt_0 <= #1 1'b0;\n    gnt_1 <= #1 1'b0;\n    gnt_2 <= #1 1'b0;\n    gnt_3 <= #1 1'b0;\n    state <= #1 IDLE;\n  end else begin\n    state <= #1 next_state;\n    case(state)\n\tIDLE : begin\n                gnt_0 <= #1 1'b0;\n                gnt_1 <= #1 1'b0;\n                gnt_2 <= #1 1'b0;\n                gnt_3 <= #1 1'b0;\n\t       end\n  \tGNT0 : begin\n  \t         gnt_0 <= #1 1'b1;\n  \t       end\n        GNT1 : begin\n                 gnt_1 <= #1 1'b1;\n               end\n        GNT2 : begin\n                 gnt_2 <= #1 1'b1;\n               end\n        GNT3 : begin\n                 gnt_3 <= #1 1'b1;\n               end\n     default : begin\n                 state <= #1 IDLE;\n               end\n    endcase\n  end\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/fsm_seq.v", "filename": "fsm_seq.v", "prompt": "Write Verilog code for Fsm Seq.", "verilog_code": "always @ (posedge clock)\nbegin : OUTPUT_LOGIC\n  if (reset == 1'b1) begin\n    gnt_0 <= #1 1'b0;\n    gnt_1 <= #1 1'b0;\n    gnt_2 <= #1 1'b0;\n    gnt_3 <= #1 1'b0;\n    state <= #1 IDLE;\n  end else begin\n    state <= #1 next_state;\n    case(state)\n       IDLE : begin\n                gnt_0 <= #1 1'b0;\n                gnt_1 <= #1 1'b0;\n                gnt_2 <= #1 1'b0;\n                gnt_3 <= #1 1'b0;\n\t       end\n  \tGNT0 : begin\n  \t         gnt_0 <= #1 1'b1;\n  \t       end\n        GNT1 : begin\n                 gnt_1 <= #1 1'b1;\n               end\n        GNT2 : begin\n                 gnt_2 <= #1 1'b1;\n               end\n        GNT3 : begin\n                 gnt_3 <= #1 1'b1;\n               end\n     default : begin\n                 state <= #1 IDLE;\n               end\n    endcase\n  end\nend", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/adder_4_bit_using_always.v", "filename": "adder_4_bit_using_always.v", "prompt": "Write Verilog code for Adder 4 Bit Using Always.", "verilog_code": "module adder_4_bit_using_always ();\nreg[3:0] a, b;\nreg [3:0] sum;\nreg carry;\n\nalways @ (a or b) \nbegin \n  {carry,sum} = a + b; \nend \n\ninitial begin\n  $monitor (\" A = %b B = %b CARRY = %b SUM = %b\",a,b,carry,sum);\n  #10 a = 8;\n   b = 7;\n   #10 a = 10;\n   #10 b = 15;\n   #10 a = 0; \n   #10 b = 0; \n   #10 $finish; \nend\n  \nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/avoid_latch_else.v", "filename": "avoid_latch_else.v", "prompt": "Write Verilog code for Avoid Latch Else.", "verilog_code": "module avoid_latch_else ();\n\nreg q;\nreg enable, d;\n\nalways @ (enable or d)\nif (enable) begin\n  q = d;\nend else begin\n  q = 0;\nend\n\ninitial begin\n  $monitor (\" ENABLE = %b  D = %b Q = %b\",enable,d,q);\n  #1 enable = 0;\n  #1 d = 0;\n  #1 enable = 1;\n  #1 d = 1;\n  #1 d = 0;\n  #1 d = 1;\n  #1 d = 0;\n  #1 d = 1;\n  #1 enable = 0;\n  #1 $finish;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/adder_using_always.v", "filename": "adder_using_always.v", "prompt": "Write Verilog code for Adder Using Always.", "verilog_code": "module adder_using_always ();\nreg a, b;\nreg sum, carry; \n\nalways @ (a or b) \nbegin \n  {carry,sum} = a + b; \nend\n\ninitial begin \n  $monitor (\" A = %b B = %b CARRY = %b SUM = %b\",a,b,carry,sum);\n  #10 a = 0; \n   b = 0; \n   #10 a = 1; \n   #10 b = 1; \n   #10 a = 0; \n   #10 b = 0; \n   #10 $finish; \nend  \n  \nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/wrong_seq.v", "filename": "wrong_seq.v", "prompt": "Write Verilog code for Wrong Seq.", "verilog_code": "module wrong_seq();\n\nreg q;\nreg clk1, clk2, d1, d2;\n\nalways @ (posedge clk1 or posedge clk2)\nif (clk1) begin\n  q <= d1;\nend else if (clk2) begin\n  q <= d2;\nend\n\ninitial begin\n  $monitor (\"CLK1 = %b CLK2 = %b D1 = %b D2 %b Q = %b\", \n    clk1, clk2, d1, d2, q);\n  clk1 = 0;\n  clk2 = 0;\n  d1 = 0;\n  d2 = 1;\n  #10 $finish;\nend\n\nalways\n #1 clk1 = ~clk1;\n \nalways\n #1.9 clk2 = ~clk2;\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/dlatch_using_always.v", "filename": "dlatch_using_always.v", "prompt": "Write Verilog code for Dlatch Using Always.", "verilog_code": "module dlatch_using_always();\nreg q;\n\nreg d, enable;\n\nalways @ (d or enable)\nif (enable) begin\n  q = d; \nend\n\ninitial begin\n  $monitor (\" ENABLE = %b D = %b  Q = %b\",enable,d,q);\n  #1 enable = 0;\n  #1 d = 1;\n  #1 enable = 1;\n  #1 d = 0;\n  #1 d = 1;\n  #1 d = 0;\n  #1 enable = 0;\n  #10 $finish;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/avoid_latch_init.v", "filename": "avoid_latch_init.v", "prompt": "Write Verilog code for Avoid Latch Init.", "verilog_code": "module avoid_latch_init ();\n\nreg q;\nreg enable, d;\n\nalways @ (enable or d)\nbegin\n  q = 0;\n  if (enable) begin\n    q = d;\n  end\nend\n\ninitial begin\n  $monitor (\" ENABLE = %b  D = %b Q = %b\",enable,d,q);\n  #1 enable = 0;\n  #1 d = 0;\n  #1 enable = 1;\n  #1 d = 1;\n  #1 d = 0;\n  #1 d = 1;\n  #1 d = 0;\n  #1 d = 1;\n  #1 enable = 0;\n  #1 $finish;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/dff_async_reset_async_preset.v", "filename": "dff_async_reset_async_preset.v", "prompt": "Write Verilog code for Dff Async Reset Async Preset.", "verilog_code": "module dff_async_reset_async_preset();\n\nreg clk,reset,preset,d;\nreg  q;\n\nalways @ (posedge clk or posedge reset or posedge preset)\nif (reset) begin\n  q <= 0;\nend else if (preset) begin\n  q <= 1;\nend else begin\n  q <= d;\nend\n\n// Testbench code here\ninitial begin\n  $monitor(\"CLK = %b RESET = %b PRESET = %b D = %b Q = %b\",\n    clk,reset,preset,d,q);\n  clk    = 0;\n  #1 reset  = 0;\n  preset = 0;\n  d      = 0;\n  #1 reset = 1;\n  #2 reset = 0;\n  #2 preset = 1;\n  #2 preset = 0;\n  repeat (4) begin\n    #2 d      = ~d;\n  end\n  #2 $finish;\nend\n\nalways\n #1 clk = ~clk;\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/named_block_disable.v", "filename": "named_block_disable.v", "prompt": "Write Verilog code for Named Block Disable.", "verilog_code": "// This code find the lowest bit set\nmodule named_block_disable();\n\nreg [31:0] bit_detect;\nreg [5:0]  bit_position;\ninteger i;\n\nalways @ (bit_detect)\nbegin : BIT_DETECT\n  for (i = 0; i < 32 ; i = i + 1) begin\n     // If bit is set, latch the bit position\n     // Disable the execution of the block\n     if (bit_detect[i] == 1) begin\n        bit_position = i;\n        disable BIT_DETECT;\n     end  else begin\n        bit_position = 32;\n     end\n  end\nend\n\n// Testbench code here\ninitial begin\n  $monitor(\" INPUT = %b  MIN_POSITION = %d\", bit_detect, bit_position);\n  #1 bit_detect = 32'h1000_1000;\n  #1 bit_detect = 32'h1100_0000;\n  #1 bit_detect = 32'h1000_1010;\n  #10 $finish;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/wait_example.v", "filename": "wait_example.v", "prompt": "Write Verilog code for Wait Example.", "verilog_code": "module wait_example();\n\nreg mem_read, data_ready;\nreg [7:0] data_bus, data;\n\nalways @ (mem_read or data_bus or data_ready)\nbegin\n  data = 0;\n  while (mem_read == 1'b1) begin\n    // #1 is very important to avoid infinite loop\n    wait (data_ready == 1) #1 data = data_bus;\n  end\nend\n\n// Testbench Code here\ninitial begin\n $monitor (\"TIME = %g READ = %b READY = %b DATA = %b\", \n   $time, mem_read, data_ready, data);\n data_bus = 0;\n mem_read = 0;\n data_ready = 0;\n #10 data_bus = 8'hDE;\n #10 mem_read = 1;\n #20 data_ready = 1;\n #1  mem_read = 1;\n #1  data_ready = 0;\n #10 data_bus = 8'hAD;\n #10 mem_read = 1;\n #20 data_ready = 1;\n #1  mem_read = 1;\n #1  data_ready = 0;\n #10 $finish;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/mux_using_assign.v", "filename": "mux_using_assign.v", "prompt": "Write Verilog code for Mux Using Assign.", "verilog_code": "module mux_using_assign();\nreg data_in_0, data_in_1;\nwire data_out;\nreg  sel;\n\nassign data_out = (sel) ? data_in_1 : data_in_0; \n\n// Testbench code here\ninitial begin\n  $monitor(\"TIME = %g SEL = %b DATA0 = %b DATA1 = %b OUT = %b\",\n    $time,sel,data_in_0,data_in_1,data_out);\n  data_in_0 = 0;\n  data_in_1 = 0;\n  sel = 0;\n  #10 sel = 1;\n  #10 $finish;\nend\n\n// Toggel data_in_0 at #1\nalways\n #1 data_in_0 = ~data_in_0;\n\n// Toggel data_in_1 at #2\nalways\n #2 data_in_1 = ~data_in_1;\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/decoder.v", "filename": "decoder.v", "prompt": "Write Verilog code for Decoder.", "verilog_code": "module decoder (in,out);\ninput [2:0] in;\noutput [7:0] out;\nwire [7:0] out;\nassign out  =  \t(in == 3'b000 ) ? 8'b0000_0001 : \n(in == 3'b001 ) ? 8'b0000_0010 : \n(in == 3'b010 ) ? 8'b0000_0100 : \n(in == 3'b011 ) ? 8'b0000_1000 : \n(in == 3'b100 ) ? 8'b0001_0000 : \n(in == 3'b101 ) ? 8'b0010_0000 : \n(in == 3'b110 ) ? 8'b0100_0000 : \n(in == 3'b111 ) ? 8'b1000_0000 : 8'h00;\n  \t  \t \nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/mux_21.v", "filename": "mux_21.v", "prompt": "Write Verilog code for Mux 21.", "verilog_code": "module mux_21 (a,b,sel,y);\n  \t  \tinput a, b;\n  \t  \toutput y;\n  \t  \tinput sel;\n  \t  \twire y;\n  \t  \t \n  \t  \tassign y = (sel) ? b : a;\n  \t  \t \nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/decoder_always.v", "filename": "decoder_always.v", "prompt": "Write Verilog code for Decoder Always.", "verilog_code": "module decoder_always (in,out);\ninput [2:0] in;\noutput [7:0] out;\nreg [7:0] out;\n \nalways @ (in)\nbegin\n  out = 0;\n  case (in)\n    3'b001 : out = 8'b0000_0001;\n    3'b010 : out = 8'b0000_0010;\n    3'b011 : out = 8'b0000_0100;\n    3'b100 : out = 8'b0000_1000;\n    3'b101 : out = 8'b0001_0000;\n    3'b110 : out = 8'b0100_0000;\n    3'b111 : out = 8'b1000_0000;\n  endcase\nend\n  \t  \t \nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/compare.v", "filename": "compare.v", "prompt": "Write Verilog code for Compare.", "verilog_code": "module fileio;\n\ninteger in,out,mon;\nreg clk;\n\nreg  enable;\nwire valid;\nreg [31:0] din;\nreg [31:0] exp;\nwire [31:0] dout;\ninteger statusI,statusO;\n\ndut dut (clk,enable,din,dout,valid);\n\ninitial begin\n  clk = 0;\n  enable  = 0;\n  din = 0;\n  exp = 0;\n  in  = $fopen(\"input.txt\",\"r\");\n  out = $fopen(\"output.txt\",\"r\");\n  mon = $fopen(\"monitor.txt\",\"w\");\nend\n\nalways # 1 clk = ~clk;\n\n// DUT input driver code\ninitial begin\n    repeat (10) @ (posedge clk);\n    while (!$feof(in)) begin\n      @ (negedge clk);\n      enable = 1;\n      statusI = $fscanf(in,\"%h %h\\n\",din[31:16],din[15:0]);\n      @ (negedge clk);\n      enable = 0;\n    end\n    repeat (10) @ (posedge clk);\n    $fclose(in);\n    $fclose(out);\n    $fclose(mon);\n    #100 $finish;\nend\n\n// DUT output monitor and compare logic\nalways @ (posedge clk)\n if (valid) begin\n   $fwrite(mon,\"%h %h\\n\",dout[31:16],dout[15:0]);\n   statusO = $fscanf(out,\"%h %h\\n\",exp[31:16],exp[15:0]);\n   if (dout !== exp) begin\n     $display(\"%0dns Error : input and output does not match\",$time);\n     $display(\"       Got  %h\",dout);\n     $display(\"       Exp  %h\",exp);\n   end else begin\n     $display(\"%0dns Match : input and output match\",$time);\n     $display(\"       Got  %h\",dout);\n     $display(\"       Exp  %h\",exp);\n   end\n end\n\nendmodule\n\n// DUT model\nmodule dut(\n  input wire clk,enable,\n  input wire [31:0] din,\n  output reg [31:0] dout,\n  output reg       valid\n);\n\nalways @ (posedge clk)\n  begin\n    dout  <= din + 1;\n    valid  <= enable;\n  end\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/adder_hier.v", "filename": "adder_hier.v", "prompt": "Write Verilog code for Adder Hier.", "verilog_code": "//-----------------------------------------------------\n// This is simple adder Program\n// Design Name : adder_hier\n// File Name   : adder_hier.v\n// Function    : This program shows verilog hier path works\n// Coder       : Deepak\n//-----------------------------------------------------\n`include \"addbit.v\"\nmodule adder_hier (\nresult        , // Output of the adder\ncarry         , // Carry output of adder\nr1            , // first input\nr2            , // second input\nci              // carry input\n);\n\n// Input Port Declarations       \ninput    [3:0]   r1         ;\ninput    [3:0]   r2         ;\ninput            ci         ;\n\n// Output Port Declarations\noutput   [3:0]  result      ;\noutput          carry       ;\n\n// Port Wires\nwire     [3:0]    r1        ;\nwire     [3:0]    r2        ;\nwire              ci        ;\nwire     [3:0]    result    ;\nwire              carry     ;\n\n// Internal variables\nwire              c1        ;\nwire              c2        ;\nwire              c3        ;\n\n// Code Starts Here\naddbit u0 (r1[0],r2[0],ci,result[0],c1);\naddbit u1 (r1[1],r2[1],c1,result[1],c2);\naddbit u2 (r1[2],r2[2],c2,result[2],c3);\naddbit u3 (r1[3],r2[3],c3,result[3],carry);\n\nendmodule // End Of Module adder\n\nmodule tb();\n\nreg [3:0] r1,r2;\nreg  ci;\nwire [3:0] result;\nwire  carry;\n\n// Drive the inputs\ninitial begin\n  r1 = 0;\n  r2 = 0;\n  ci = 0;\n  #10 r1 = 10;\n  #10 r2 = 2;\n  #10 ci = 1;\n  #10 $display(\"+--------------------------------------------------------+\");\n  $finish;\nend\n\n// Connect the lower module\nadder_hier U (result,carry,r1,r2,ci);\n\n// Hier demo here\ninitial begin\n  $display(\"+--------------------------------------------------------+\");\n  $display(\"|  r1  |  r2  |  ci  | u0.sum | u1.sum | u2.sum | u3.sum |\");\n  $display(\"+--------------------------------------------------------+\");\n  $monitor(\"|  %h   |  %h   |  %h   |    %h    |   %h   |   %h    |   %h    |\",\n  r1,r2,ci, tb.U.u0.sum, tb.U.u1.sum, tb.U.u2.sum, tb.U.u3.sum); \nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/strings.v", "filename": "strings.v", "prompt": "Write Verilog code for Strings.", "verilog_code": "//-----------------------------------------------------\n// Design Name : strings\n// File Name   : strings.v\n// Function    : This program shows how string\n//               can be stored in reg\n// Coder      : Deepak Kumar Tala\n//-----------------------------------------------------\nmodule strings();\n// Declare a register variable that is 21 bytes\nreg [8*21:0] string ;\n\ninitial begin\n  string = \"This is sample string\";\n  $display (\"%s \\n\", string);\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/gates.v", "filename": "gates.v", "prompt": "Write Verilog code for Gates.", "verilog_code": "module gates();\n\nwire out0;\nwire out1;\nwire out2;\nreg  in1,in2,in3,in4;\n\nnot U1(out0,in1);\nand U2(out1,in1,in2,in3,in4);\nxor U3(out2,in1,in2,in3);\n\ninitial begin\n  $monitor(\n  \"in1=%b in2=%b in3=%b in4=%b out0=%b out1=%b out2=%b\",\n   in1,in2,in3,in4,out0,out1,out2); \n  in1 = 0;\n  in2 = 0;\n  in3 = 0;\n  in4 = 0;\n  #1 in1 = 1;\n  #1 in2 = 1;\n  #1 in3 = 1;\n  #1 in4 = 1;\n  #1 $finish; \nend\t\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/transmission_gates.v", "filename": "transmission_gates.v", "prompt": "Write Verilog code for Transmission Gates.", "verilog_code": "module transmission_gates();  \n\nreg data_enable_low, in;\nwire data_bus, out1, out2;\n\nbufif0 U1(data_bus,in, data_enable_low);\nbuf  U2(out1,in);\nnot U3(out2,in);\n\ninitial begin\n  $monitor(\n    \"@%g in=%b data_enable_low=%b out1=%b out2= b data_bus=%b\", \n    $time, in, data_enable_low, out1, out2, data_bus);\n  data_enable_low = 0;\n  in = 0;\n  #4 data_enable_low = 1;\n  #8 $finish;\nend\n\nalways #2 in = ~in;\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/counter.v", "filename": "counter.v", "prompt": "Write Verilog code for Counter.", "verilog_code": "//-----------------------------------------------------\r\n// Design Name : counter\r\n// File Name   : counter.v\r\n// Function    : 4 bit up counter\r\n// Coder       : Deepak\r\n//-----------------------------------------------------\r\nmodule counter (clk, reset, enable, count);\r\ninput clk, reset, enable;\r\noutput [3:0] count;\r\nreg [3:0] count;                                   \r\n\r\nalways @ (posedge clk)\r\nif (reset == 1'b1) begin\r\n  count <= 0;\r\nend else if ( enable == 1'b1) begin\r\n  count <= count + 1;\r\nend\r\n\r\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/memory.v", "filename": "memory.v", "prompt": "Write Verilog code for Memory.", "verilog_code": "module  memory();\nreg [7:0] my_memory [0:255];\n\ninitial begin\n $readmemh(\"memory.list\", my_memory);\nend\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/syn_fifo_psl.v", "filename": "syn_fifo_psl.v", "prompt": "Write Verilog code for Syn Fifo Psl.", "verilog_code": "//=============================================\n// Function  : Synchronous (single clock) FIFO\n//             With Assertion\n// Coder     : Deepak Kumar Tala\n// Date      : 31-October-2002\n//=============================================\nmodule syn_fifo (\nclk      , // Clock input\nrst      , // Active high reset\nwr_cs    , // Write chip select\nrd_cs    , // Read chipe select\ndata_in  , // Data input\nrd_en    , // Read enable\nwr_en    , // Write Enable\ndata_out , // Data Output\nempty    , // FIFO empty\nfull       // FIFO full\n);    \n \n// FIFO constants\nparameter DATA_WIDTH = 8;\nparameter ADDR_WIDTH = 8;\nparameter RAM_DEPTH = (1 << ADDR_WIDTH);\n// Port Declarations\ninput clk ;\ninput rst ;\ninput wr_cs ;\ninput rd_cs ;\ninput rd_en ;\ninput wr_en ;\ninput [DATA_WIDTH-1:0] data_in ;\noutput full ;\noutput empty ;\noutput [DATA_WIDTH-1:0] data_out ;\n\n//-----------Internal variables-------------------\nreg [ADDR_WIDTH-1:0] wr_pointer;\nreg [ADDR_WIDTH-1:0] rd_pointer;\nreg [ADDR_WIDTH :0] status_cnt;\nreg [DATA_WIDTH-1:0] data_out ;\nwire [DATA_WIDTH-1:0] data_ram ;\n\n//-----------Variable assignments---------------\nassign full = (status_cnt == (RAM_DEPTH-1));\nassign empty = (status_cnt == 0);\n\n//-----------Code Start---------------------------\nalways @ (posedge clk or posedge rst)\nbegin : WRITE_POINTER\n  if (rst) begin\n   wr_pointer <= 0;\n  end else if (wr_cs && wr_en ) begin\n   wr_pointer <= wr_pointer + 1;\n  end\nend\n\nalways @ (posedge clk or posedge rst)\nbegin : READ_POINTER\n  if (rst) begin\n    rd_pointer <= 0;\n    data_out <= 0;\n  end else if (rd_cs && rd_en ) begin\n    rd_pointer <= rd_pointer + 1;\n    data_out <= data_ram;\n  end\nend\n\nalways  @ (posedge clk or posedge rst)\nbegin : READ_DATA\n  if (rst) begin\n    data_out <= 0;\n  end else if (rd_cs && rd_en ) begin\n    data_out <= data_ram;\n  end\nend\n\nalways @ (posedge clk or posedge rst)\nbegin : STATUS_COUNTER\n  if (rst) begin\n    status_cnt <= 0;\n  // Read but no write.\n  end else if ((rd_cs && rd_en) && !(wr_cs && wr_en) \n                && (status_cnt != 0)) begin\n    status_cnt <= status_cnt - 1;\n  // Write but no read.\n  end else if ((wr_cs && wr_en) && !(rd_cs && rd_en) \n               && (status_cnt != RAM_DEPTH)) begin\n    status_cnt <= status_cnt + 1;\n  end\nend \n   \nram_dp_ar_aw #(DATA_WIDTH,ADDR_WIDTH) DP_RAM (\n.address_0 (wr_pointer) , // address_0 input \n.data_0    (data_in)    , // data_0 bi-directional\n.cs_0      (wr_cs)      , // chip select\n.we_0      (wr_en)      , // write enable\n.oe_0      (1'b0)       , // output enable\n.address_1 (rd_pointer) , // address_q input\n.data_1    (data_ram)   , // data_1 bi-directional\n.cs_1      (rd_cs)      , // chip select\n.we_1      (1'b0)       , // Read enable\n.oe_1      (rd_en)        // output enable\n);  \n\n// Add assertion here\n// psl default clock = (posedge clk);\n// psl ERRORwritefull: assert never {full && wr_en && wr_cs};\n// psl ERRORreadempty: assert never {empty && rd_en && rd_cs};\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/equality_operators.v", "filename": "equality_operators.v", "prompt": "Write Verilog code for Equality Operators.", "verilog_code": "module equality_operators();\n\ninitial begin\n  // Case Equality\n  $display (\" 4'bx001 ===  4'bx001 = %b\", (4'bx001 ===  4'bx001));\n  $display (\" 4'bx0x1 ===  4'bx001 = %b\", (4'bx0x1 ===  4'bx001));\n  $display (\" 4'bz0x1 ===  4'bz0x1 = %b\", (4'bz0x1 ===  4'bz0x1));\n  $display (\" 4'bz0x1 ===  4'bz001 = %b\", (4'bz0x1 ===  4'bz001));\n  // Case Inequality\n  $display (\" 4'bx0x1 !==  4'bx001 = %b\", (4'bx0x1 !==  4'bx001));\n  $display (\" 4'bz0x1 !==  4'bz001 = %b\", (4'bz0x1 !==  4'bz001));  \n  // Logical Equality\n  $display (\" 5       ==   10      = %b\", (5       ==   10));\n  $display (\" 5       ==   5       = %b\", (5       ==   5));\n  // Logical Inequality\n  $display (\" 5       !=   5       = %b\", (5       !=   5));\n  $display (\" 5       !=   6       = %b\", (5       !=   6));\n  #10 $finish;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/arithmetic_operators.v", "filename": "arithmetic_operators.v", "prompt": "Write Verilog code for Arithmetic Operators.", "verilog_code": "module arithmetic_operators();\n\ninitial begin\n  $display (\" 5  +  10 = %d\", 5  + 10);\n  $display (\" 5  -  10 = %d\", 5  - 10);\n  $display (\" 10 -  5  = %d\", 10 - 5);\n  $display (\" 10 *  5  = %d\", 10 * 5);\n  $display (\" 10 /  5  = %d\", 10 / 5);\n  $display (\" 10 /  -5 = %d\", 10 / -5);\n  $display (\" 10 %s  3  = %d\",\"%\", 10 % 3);\n  $display (\" +5       = %d\", +5);\n  $display (\" -5       = %d\", -5);\n  #10 $finish;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/logical_operators.v", "filename": "logical_operators.v", "prompt": "Write Verilog code for Logical Operators.", "verilog_code": "module logical_operators();\n\ninitial begin\n  // Logical AND\n  $display (\"1'b1 && 1'b1 = %b\", (1'b1 && 1'b1));\n  $display (\"1'b1 && 1'b0 = %b\", (1'b1 && 1'b0));\n  $display (\"1'b1 && 1'bx = %b\", (1'b1 && 1'bx));\n  // Logical OR\n  $display (\"1'b1 || 1'b0 = %b\", (1'b1 || 1'b0));\n  $display (\"1'b0 || 1'b0 = %b\", (1'b0 || 1'b0));\n  $display (\"1'b0 || 1'bx = %b\", (1'b0 || 1'bx));\n  // Logical Negation\n  $display (\"! 1'b1       = %b\", (!  1'b1));\n  $display (\"! 1'b0       = %b\", (!  1'b0));\n  #10 $finish;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/relational_operators.v", "filename": "relational_operators.v", "prompt": "Write Verilog code for Relational Operators.", "verilog_code": "module relational_operators();\n\ninitial begin\n  $display (\" 5     <=  10 = %b\", (5     <= 10));\n  $display (\" 5     >=  10 = %b\", (5     >= 10));\n  $display (\" 1'bx  <=  10 = %b\", (1'bx  <= 10));\n  $display (\" 1'bz  <=  10 = %b\", (1'bz  <= 10));  \n  #10 $finish;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/bitwise_operators.v", "filename": "bitwise_operators.v", "prompt": "Write Verilog code for Bitwise Operators.", "verilog_code": "module bitwise_operators();\n\ninitial begin\n  // Bit Wise Negation\n  $display (\" ~4'b0001           = %b\", (~4'b0001));\n  $display (\" ~4'bx001           = %b\", (~4'bx001));\n  $display (\" ~4'bz001           = %b\", (~4'bz001));\n  // Bit Wise AND\n  $display (\" 4'b0001 &  4'b1001 = %b\", (4'b0001 &  4'b1001));\n  $display (\" 4'b1001 &  4'bx001 = %b\", (4'b1001 &  4'bx001));\n  $display (\" 4'b1001 &  4'bz001 = %b\", (4'b1001 &  4'bz001));\n  // Bit Wise OR\n  $display (\" 4'b0001 |  4'b1001 = %b\", (4'b0001 |  4'b1001));\n  $display (\" 4'b0001 |  4'bx001 = %b\", (4'b0001 |  4'bx001));\n  $display (\" 4'b0001 |  4'bz001 = %b\", (4'b0001 |  4'bz001));\n  // Bit Wise XOR\n  $display (\" 4'b0001 ^  4'b1001 = %b\", (4'b0001 ^  4'b1001));\n  $display (\" 4'b0001 ^  4'bx001 = %b\", (4'b0001 ^  4'bx001));\n  $display (\" 4'b0001 ^  4'bz001 = %b\", (4'b0001 ^  4'bz001));\n  // Bit Wise XNOR\n  $display (\" 4'b0001 ~^ 4'b1001 = %b\", (4'b0001 ~^ 4'b1001));\n  $display (\" 4'b0001 ~^ 4'bx001 = %b\", (4'b0001 ~^ 4'bx001));\n  $display (\" 4'b0001 ~^ 4'bz001 = %b\", (4'b0001 ~^ 4'bz001));\n  #10 $finish;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/udp_latch.v", "filename": "udp_latch.v", "prompt": "Write Verilog code for Udp Latch.", "verilog_code": "primitive udp_latch(q, clk, d) ;\noutput q;   \ninput clk, d;\n\nreg q;\n\ntable\n  //clk d    q     q+\n  0     1  : ? :   1   ;\n  0     0  : ? :   0   ;\n  1     ?  : ? :   -   ; \nendtable\n\nendprimitive", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/bus_wr_rd_task.v", "filename": "bus_wr_rd_task.v", "prompt": "Write Verilog code for Bus Wr Rd Task.", "verilog_code": "module bus_wr_rd_task();\n\nreg clk,rd,wr,ce;\nreg [7:0]  addr,data_wr,data_rd;\nreg [7:0]  read_data;\n\ninitial begin\n  clk = 0;\n  read_data = 0;\n  rd = 0;\n  wr = 0;\n  ce = 0;\n  addr = 0;\n  data_wr = 0;\n  data_rd = 0;\n  // Call the write and read tasks here\n  #1 cpu_write(8'h11,8'hAA);\n  #1 cpu_read(8'h11,read_data);\n  #1 cpu_write(8'h12,8'hAB);\n  #1 cpu_read(8'h12,read_data);\n  #1 cpu_write(8'h13,8'h0A);\n  #1 cpu_read(8'h13,read_data);\n  #100 $finish;\nend\n// Clock Generator\nalways\n  #1 clk = ~clk;\n// CPU Read Task\ntask cpu_read;\n  input [7:0]  address;\n  output [7:0] data;\n  begin\n    $display (\"%g CPU Read  task with address : %h\", $time, address);\n    $display (\"%g  -> Driving CE, RD and ADDRESS on to bus\", $time);\n    @ (posedge clk);\n    addr = address;\n    ce = 1;\n    rd = 1;\n    @ (negedge clk);\n    data = data_rd;\n    @ (posedge clk);\n    addr = 0;\n    ce = 0;\n    rd = 0;\n    $display (\"%g CPU Read  data              : %h\", $time, data);\n    $display (\"======================\");\n  end\nendtask\n// CU Write Task\ntask cpu_write;\n  input [7:0]  address;\n  input [7:0] data;\n  begin\n    $display (\"%g CPU Write task with address : %h Data : %h\", \n      $time, address,data);\n    $display (\"%g  -> Driving CE, WR, WR data and ADDRESS on to bus\", \n      $time);\n    @ (posedge clk);\n    addr = address;\n    ce = 1;\n    wr = 1;\n    data_wr = data;\n    @ (posedge clk);\n    addr = 0;\n    ce = 0;\n    wr = 0;\n    $display (\"======================\");\n  end\nendtask\n\n// Memory model for checking tasks\nreg [7:0] mem [0:255];\n\nalways @ (addr or ce or rd or wr or data_wr)\nif (ce) begin\n  if (wr) begin\n    mem[addr] = data_wr;\n  end\n  if (rd) begin\n    data_rd = mem[addr];\n  end\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/arbiter.v", "filename": "arbiter.v", "prompt": "Write Verilog code for Arbiter.", "verilog_code": "module arbiter (\r\nclock, \r\nreset, \r\nreq_0,\r\nreq_1, \r\ngnt_0,\r\ngnt_1\r\n);\r\n\r\ninput clock, reset, req_0, req_1;\r\noutput gnt_0, gnt_1;\r\n\r\nreg gnt_0, gnt_1;\r\n\r\nalways @ (posedge clock or posedge reset)\r\nif (reset) begin\r\n gnt_0 <= 0;\r\n gnt_1 <= 0;\r\nend else if (req_0) begin\r\n  gnt_0 <= 1;\r\n  gnt_1 <= 0;\r\nend else if (req_1) begin\r\n  gnt_0 <= 0;\r\n  gnt_1 <= 1;\r\nend\r\n\r\nendmodule\r\n// Testbench Code Goes here\r\nmodule arbiter_tb;\r\n\r\nreg clock, reset, req0,req1;\r\nwire gnt0,gnt1;\r\n\r\ninitial begin\r\n  $monitor (\"req0=%b,req1=%b,gnt0=%b,gnt1=%b\", req0,req1,gnt0,gnt1);\r\n  clock = 0;\r\n  reset = 0;\r\n  req0 = 0;\r\n  req1 = 0;\r\n  #5 reset = 1;\r\n  #15 reset = 0;\r\n  #10 req0 = 1;\r\n  #10 req0 = 0;\r\n  #10 req1 = 1;\r\n  #10 req1 = 0;\r\n  #10 {req0,req1} = 2'b11;\r\n  #10 {req0,req1} = 2'b00;\r\n  #10 $finish;\r\nend\r\n\r\nalways begin\r\n #5 clock = !clock;\r\nend\r\n\r\narbiter U0 (\r\n.clock (clock),\r\n.reset (reset),\r\n.req_0 (req0),\r\n.req_1 (req1),\r\n.gnt_0 (gnt0),\r\n.gnt_1 (gnt1)\r\n);\r\n\r\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/udp_syntax.v", "filename": "udp_syntax.v", "prompt": "Write Verilog code for Udp Syntax.", "verilog_code": "//This code shows how input/output ports\n// and primitve is declared\nprimitive udp_syntax (\na, // Port a\nb, // Port b\nc, // Port c\nd  // Port d\n);\noutput a;\ninput b,c,d;\n\n// UDP function code here\n\nendprimitive", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/delay_example.v", "filename": "delay_example.v", "prompt": "Write Verilog code for Delay Example.", "verilog_code": "module delay_example();\n\nwire out1,out2,out3,out4,out5,out6;\nreg b,c;\n\n// Delay for all transitions\nor     #5                   u_or     (out1,b,c);\n// Rise and fall delay\nand    #(1,2)               u_and    (out2,b,c);\n// Rise, fall and turn off delay\nnor    #(1,2,3)             u_nor    (out3,b,c);\n//One Delay, min, typ and max\nnand   #(1:2:3)             u_nand   (out4,b,c);\n//Two delays, min,typ and max\nbuf    #(1:4:8,4:5:6)       u_buf    (out5,b);\n//Three delays, min, typ, and max\nnotif1 #(1:2:3,4:5:6,7:8:9) u_notif1 (out6,b,c);\n\n//Testbench code\ninitial begin\n  $monitor (\n  \"Time=%g b=%b c=%b  out1=%b out2=%b out3=%b out4=%b out5=%b out6=%b\", \n    $time, b, c , out1, out2, out3, out4, out5, out6); \n  b = 0;\n  c = 0;\n  #10 b = 1;\n  #10 c = 1;\n  #10 b = 0;\n  #10 $finish;\nend\t\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/buf_gate.v", "filename": "buf_gate.v", "prompt": "Write Verilog code for Buf Gate.", "verilog_code": "module  buf_gate ();\nreg in;\nwire out;\n\t \nbuf #(5) (out,in);\n\ninitial begin\n  $monitor (\"Time = %g in = %b out=%b\", $time, in, out);\n  in = 0;\n  #10 in = 1;\n  #10 in = 0;\n  #10 $finish;\nend\n  \t \nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/n_out_primitive.v", "filename": "n_out_primitive.v", "prompt": "Write Verilog code for N Out Primitive.", "verilog_code": "module n_out_primitive();\n\nwire out,out_0,out_1,out_2,out_3,out_a,out_b,out_c;\nwire in;\n\n// one output Buffer gate\nbuf u_buf0 (out,in);\n// four output Buffer gate \nbuf u_buf1 (out_0, out_1, out_2, out_3, in);\n// three output Invertor gate \nnot u_not0 (out_a, out_b, out_c, in);\n \nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/n_in_primitive.v", "filename": "n_in_primitive.v", "prompt": "Write Verilog code for N In Primitive.", "verilog_code": "module n_in_primitive();\n\nwire out1,out2,out3;\nreg in1,in2,in3,in4;\n\n// Two input AND gate\nand u_and1 (out1, in1, in2);\n// four input AND gate \nand u_and2 (out2, in1, in2, in3, in4);\n// three input XNOR gate \nxnor u_xnor1 (out3, in1, in2, in3);\n\n//Testbench Code\ninitial begin\n  $monitor (\n  \"in1 = %b in2 = %b in3 = %b in4 = %b out1 = %b out2 = %b out3 = %b\",\n  in1, in2, in3, in4, out1, out2, out3);\n  in1 = 0;\n  in2 = 0;\n  in3 = 0;\n  in4 = 0;\n  #1 in1 = 1;\n  #1 in2 = 1;\n  #1 in3 = 1;\n  #1 in4 = 1;\n  #1 $finish;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/buf_gate1.v", "filename": "buf_gate1.v", "prompt": "Write Verilog code for Buf Gate1.", "verilog_code": "module  buf_gate1 ();\nreg in;\nwire out;\n\t \nbuf #(2,3) (out,in);\n\ninitial begin\n  $monitor (\"Time = %g in = %b out=%b\", $time, in, out);\n  in = 0;\n  #10 in = 1;\n  #10 in = 0;\n  #10 $finish;\nend\n  \t \nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/v2k_reg.v", "filename": "v2k_reg.v", "prompt": "Write Verilog code for V2K Reg.", "verilog_code": "module v2k_reg();\n\n// v2k allows to init variables\nreg a = 0;\n// Here only last variable is set to 0, i.e d = 0\n// Rest b, c are set to x\nreg b, c, d = 0;\n// reg data type can be signed in v2k\n// We can assign with signed constants\nreg signed [7:0] data = 8'shF0;\n\n// Function can return signed values\n// Its ports can contain signed ports\nfunction signed [7:0] adder;\n  input a_in;\n  input b_in;\n  input c_in;\n  input signed [7:0] data_in;\n  begin\n    adder = a_in + b_in + c_in + data_in;\n  end\nendfunction\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/comma_edge_example.v", "filename": "comma_edge_example.v", "prompt": "Write Verilog code for Comma Edge Example.", "verilog_code": "module comma_edge_example();\n\nreg clk, reset, d;\nreg q, q95;\n\n// Verilog 2k example for usage of comma\nalways @ (posedge clk, posedge reset)\nbegin : V2K\n  if (reset) q <= 0;\n  else q <= d; \nend\n\n// Verilog 95 example for above code\nalways @ (posedge clk or posedge reset)\nbegin : V95\n  if (reset) q95 <= 0;\n  else q95 <= d; \nend\n\ninitial begin\n  $monitor (\"%g clk=%b reset=%b d=%b q=%b q95=%b\", \n    $time, clk, reset, d, q, q95);\n  clk = 0;\n  reset = 0;\n  d = 0;\n  #4 reset = 1;\n  #4 reset = 0;\n  #1 d = 1;\n  #10 $finish;\nend\n\ninitial #1 forever clk = #1 ~clk;\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/ansiport_example.v", "filename": "ansiport_example.v", "prompt": "Write Verilog code for Ansiport Example.", "verilog_code": "module ansiport_example();\n\nreg read,write = 0;\nreg [7:0] data_in  = 0;\nreg [3:0] addr = 0;\nwire [7:0] data_v95, data_notype, data_ansi;\n\ninitial begin\n  $monitor (\n  \"%g rd=%b wr=%b addr=%b data_in=%h data_v95=%h data_notype=%h data_ansi=%h\"\n  , $time, read, write, addr, data_in, data_v95, data_notype, data_ansi);\n  #1 read = 0; // why only for read ?\n  #3 repeat (16) begin\n    data_in = $random;\n    write = 1;\n    #1 addr = addr + 1;\n  end\n  write = 0;\n  addr = 0;\n  #3 repeat (16) begin\n    read = 1;\n    #1 addr = addr + 1;\n  end\n  read = 0;\n  #1 $finish;\nend  \n\nmemory_v95         U (read, write, data_in, addr, data_v95);\nmemory_ansi_notype W (read, write, data_in, addr, data_notype);\nmemory_ansi        V (read, write, data_in, addr, data_ansi);\n\nendmodule\n// Verilog 95 code\nmodule memory_v95 ( read, write, data_in, addr, data_out);\ninput  read;\ninput  write;\ninput  [7:0] data_in;\ninput  [3:0] addr;\noutput  [7:0] data_out;\n\nreg [7:0] data_out;\nreg [7:0] mem [0:15];\n\nalways @ (*)\nbegin\n  if (write) mem[addr] = data_in;\nend\n\nalways @ (read, addr)\nbegin\n  if (read) data_out = mem[addr];\nend\n\nendmodule\n\n// Verilog 2k with notype in port list\nmodule memory_ansi_notype (\n  input  read,\n  input  write,\n  input  [7:0] data_in,\n  input  [3:0] addr,\n  output  [7:0] data_out\n);\nreg [7:0] mem [0:15];\n\nalways @ (*)\nbegin\n  if (write) mem[addr] = data_in;\nend\n\nassign data_out = (read) ? mem[addr] : 0;\n\nendmodule\n\n// Verilog 2k with width and data type listed\nmodule memory_ansi (\n  input wire read,\n  input wire write,\n  input wire [7:0] data_in,\n  input wire [3:0] addr,\n  output reg [7:0] data_out\n);\n\nreg [7:0] mem [0:15];\n\nalways @ (*)\nbegin\n  if (write) mem[addr] = data_in;\nend\n\nalways @ (read, addr)\nbegin\n  if (read) data_out = mem[addr];\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/star_example.v", "filename": "star_example.v", "prompt": "Write Verilog code for Star Example.", "verilog_code": "module star_example();\n\nreg a, b, c, d, e;\nreg [2:0] sum, sum95;\n\n// Verilog 2k example for usage of star for combo logic\nalways @ (*)\nbegin : SUM_V2K\n  sum = a + b + c + d + e; \nend\n\n// Verilog 95 example for above code\nalways @ (a or b or c or d or e)\nbegin : SUM_V95\n  sum95 = a + b + c + d + e; \nend\n\ninitial begin\n  $monitor (\"%g a=%b b=%b c=%b d=%b e=%b sum=%b sum95=%b\", \n    $time, a, b, c, d, e, sum, sum95);\n  #1 a = 1;\n  #1 b = 1;\n  #1 c = 1;\n  #1 d = 1;\n  #1 e = 1;\n  #1 $finish;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/power_operator.v", "filename": "power_operator.v", "prompt": "Write Verilog code for Power Operator.", "verilog_code": "module power_operator();\n\nreg [3:0] base = 2;\nreg [5:0] exponent = 1;\nreg [31:0] result = 0;\n\ninitial begin\n  $monitor (\"base = %d exponent = %d result = %d\", base, exponent, result);\n  repeat (10) begin\n    #1 exponent = exponent + 1;\n  end\n  #1 $finish;\nend \n\nalways @ (*)\nbegin\n  result = base ** exponent;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/comma_example.v", "filename": "comma_example.v", "prompt": "Write Verilog code for Comma Example.", "verilog_code": "module comma_example();\n\nreg a, b, c, d, e;\nreg [2:0] sum, sum95;\n\n// Verilog 2k example for usage of comma\nalways @ (a, b, c, d, e)\nbegin : SUM_V2K\n  sum = a + b + c + d + e; \nend\n\n// Verilog 95 example for above code\nalways @ (a or b or c or d or e)\nbegin : SUM_V95\n  sum95 = a + b + c + d + e; \nend\n\ninitial begin\n  $monitor (\"%g a=%b b=%b c=%b d=%b e=%b sum=%b sum95=%b\", \n    $time, a, b, c, d, e, sum, sum95);\n  #1 a = 1;\n  #1 b = 1;\n  #1 c = 1;\n  #1 d = 1;\n  #1 e = 1;\n  #1 $finish;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/assign_deassign.v", "filename": "assign_deassign.v", "prompt": "Write Verilog code for Assign Deassign.", "verilog_code": "module assign_deassign ();\n\nreg clk,rst,d,preset;\nwire q;\n\ninitial begin\n  $monitor(\"@%g clk %b rst %b preset %b d %b q %b\", \n    $time, clk, rst, preset, d, q);\n  clk = 0;\n  rst = 0;\n  d  = 0;\n  preset = 0;\n  #10 rst = 1;\n  #10 rst = 0;\n  repeat (10) begin\n    @ (posedge clk);\n    d <= $random;\n    @ (negedge clk) ;\n    preset <= ~preset;\n  end\n  #1 $finish;\nend\n// Clock generator\nalways #1 clk = ~clk;\n\n// assign and deassign q of flip flop module\nalways @(preset)\nif (preset) begin\n  assign U.q = 1; // assign procedural statement\nend else begin\n deassign U.q;    // deassign procedural statement\nend\n\nd_ff U (clk,rst,d,q);\n\nendmodule\n\n// D Flip-Flop model\nmodule d_ff (clk,rst,d,q);\ninput clk,rst,d;\noutput q;\nreg q;\n\nalways @ (posedge clk)\nif (rst) begin\n  q <= 0;\nend else begin\n  q <= d;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/initial_fork_join.v", "filename": "initial_fork_join.v", "prompt": "Write Verilog code for Initial Fork Join.", "verilog_code": "module initial_fork_join();\nreg clk,reset,enable,data;\n\ninitial begin\n $monitor(\"%g clk=%b reset=%b enable=%b data=%b\", \n   $time, clk, reset, enable, data);\n fork\n   #1  clk = 0;\n   #10 reset = 0;\n   #5  enable = 0;\n   #3  data = 0;\n join\n #1 $display (\"%g Terminating simulation\", $time);\n $finish;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/fork_join.v", "filename": "fork_join.v", "prompt": "Write Verilog code for Fork Join.", "verilog_code": "module fork_join();\n\nreg clk,reset,enable,data;\n\ninitial  begin\n  $display (\"Starting simulation\");\n  $monitor(\"%g clk=%b reset=%b enable=%b data=%b\", \n    $time, clk, reset, enable, data);\n  fork : FORK_VAL\n    #1 clk = 0;\n    #5 reset = 0;\n    #5 enable = 0;\n    #2 data = 0;\n  join\n  #10 $display (\"%g Terminating simulation\", $time);\n  $finish;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/force_release.v", "filename": "force_release.v", "prompt": "Write Verilog code for Force Release.", "verilog_code": "module force_release ();\n\nreg clk,rst,d,preset;\nwire q;\n\ninitial begin\n  $monitor(\"@%g clk %b rst %b preset %b d %b q %b\", \n    $time, clk, rst, preset, d, q);\n  clk = 0;\n  rst = 0;\n  d  = 0;\n  preset = 0;\n  #10 rst = 1;\n  #10 rst = 0;\n  repeat (10) begin\n    @ (posedge clk);\n    d <= $random;\n    @ (negedge clk) ;\n    preset <= ~preset;\n  end\n  #1 $finish;\nend\n// Clock generator\nalways #1 clk = ~clk;\n\n// force and release of flip flop module\nalways @(preset)\nif (preset) begin\n  force U.q = preset; // force procedural statement\nend else begin\n  release U.q;    // release procedural statement\nend\n\nd_ff U (clk,rst,d,q);\n\nendmodule\n\n// D Flip-Flop model\nmodule d_ff (clk,rst,d,q);\ninput clk,rst,d;\noutput q;\nwire q;\nreg q_reg;\n\nassign q = q_reg;\n\nalways @ (posedge clk)\nif (rst) begin\n  q_reg <= 0;\nend else begin\n  q_reg <= d;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/concatenation_operator.v", "filename": "concatenation_operator.v", "prompt": "Write Verilog code for Concatenation Operator.", "verilog_code": "module concatenation_operator();\n\ninitial begin\n  // concatenation\n  $display (\" {4'b1001,4'b10x1}  = %b\", {4'b1001,4'b10x1});\n  #10 $finish;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/replication_operator.v", "filename": "replication_operator.v", "prompt": "Write Verilog code for Replication Operator.", "verilog_code": "module replication_operator();\n\ninitial begin\n  // replication\n  $display (\" {4{4'b1001}}      = %b\", {4{4'b1001}});\n  // replication and concatenation\n  $display (\" {4{4'b1001,1'bz}} = %b\", {4{4'b1001,1'bz}});\n  #10 $finish;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/reduction_operators.v", "filename": "reduction_operators.v", "prompt": "Write Verilog code for Reduction Operators.", "verilog_code": "module reduction_operators();\n\ninitial begin\n  // Bit Wise AND reduction\n  $display (\" &  4'b1001 = %b\", (&  4'b1001));\n  $display (\" &  4'bx111 = %b\", (&  4'bx111));\n  $display (\" &  4'bz111 = %b\", (&  4'bz111));\n  // Bit Wise NAND reduction\n  $display (\" ~& 4'b1001 = %b\", (~& 4'b1001));\n  $display (\" ~& 4'bx001 = %b\", (~& 4'bx001));\n  $display (\" ~& 4'bz001 = %b\", (~& 4'bz001));\n  // Bit Wise OR reduction\n  $display (\" |  4'b1001 = %b\", (|  4'b1001));\n  $display (\" |  4'bx000 = %b\", (|  4'bx000));\n  $display (\" |  4'bz000 = %b\", (|  4'bz000));\n  // Bit Wise OR reduction\n  $display (\" ~| 4'b1001 = %b\", (~| 4'b1001));\n  $display (\" ~| 4'bx001 = %b\", (~| 4'bx001));\n  $display (\" ~| 4'bz001 = %b\", (~| 4'bz001));\n  // Bit Wise XOR reduction\n  $display (\" ^  4'b1001 = %b\", (^  4'b1001));\n  $display (\" ^  4'bx001 = %b\", (^  4'bx001));\n  $display (\" ^  4'bz001 = %b\", (^  4'bz001));\n  // Bit Wise XNOR\n  $display (\" ~^ 4'b1001 = %b\", (~^ 4'b1001));\n  $display (\" ~^ 4'bx001 = %b\", (~^ 4'bx001));\n  $display (\" ~^ 4'bz001 = %b\", (~^ 4'bz001));\n  #10 $finish;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/shift_operators.v", "filename": "shift_operators.v", "prompt": "Write Verilog code for Shift Operators.", "verilog_code": "module shift_operators();\n\ninitial begin\n  // Left Shift\n  $display (\" 4'b1001 << 1 = %b\", (4'b1001 << 1));\n  $display (\" 4'b10x1 << 1 = %b\", (4'b10x1 << 1));\n  $display (\" 4'b10z1 << 1 = %b\", (4'b10z1 << 1));\n  // Right Shift\n  $display (\" 4'b1001 >> 1 = %b\", (4'b1001 >> 1));\n  $display (\" 4'b10x1 >> 1 = %b\", (4'b10x1 >> 1));\n  $display (\" 4'b10z1 >> 1 = %b\", (4'b10z1 >> 1));\n  #10 $finish;\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/verilog_tutorial/conditional_operator.v", "filename": "conditional_operator.v", "prompt": "Write Verilog code for Conditional Operator.", "verilog_code": "module conditional_operator();\n\nwire out;\nreg enable,data;\n// Tri state buffer\nassign out = (enable) ? data : 1'bz;\n\ninitial begin\n  $display (\"time\\t enable data out\");\n  $monitor (\"%g\\t %b      %b    %b\",$time,enable,data,out);\n  enable = 0;\n  data = 0;\n  #1 data = 1;\n  #1 data = 0;\n  #1 enable = 1;\n  #1 data = 1;\n  #1 data = 0;\n  #1 enable = 0;\n  #10 $finish;\nend\t\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/encoder_using_if.v", "filename": "encoder_using_if.v", "prompt": "Write Verilog code for Encoder Using If.", "verilog_code": "//-----------------------------------------------------\n// Design Name : encoder_using_if\n// File Name   : encoder_using_if.v\n// Function    : Encoder using If\n// Coder       : Deepak Kumar Tala\n//-----------------------------------------------------\nmodule encoder_using_if(\nbinary_out , //  4 bit binary output\nencoder_in , //  16-bit input\nenable       //  Enable for the encoder\n); \n//-----------Output Ports---------------\noutput [3:0] binary_out  ;\n//-----------Input Ports---------------\ninput  enable ; \ninput [15:0] encoder_in ; \n//------------Internal Variables--------\nreg [3:0] binary_out ;  \n//-------------Code Start-----------------\nalways @ (enable or encoder_in)\n begin \n   binary_out = 0; \n   if (enable) begin\n     if (encoder_in == 16'h0002) begin\n      binary_out = 1;\n     end  if (encoder_in == 16'h0004) begin \n      binary_out = 2; \n     end  if (encoder_in == 16'h0008) begin \n      binary_out = 3; \n     end  if (encoder_in == 16'h0010) begin \n      binary_out = 4; \n     end  if (encoder_in == 16'h0020) begin \n      binary_out = 5; \n     end  if (encoder_in == 16'h0040) begin \n      binary_out = 6; \n     end  if (encoder_in == 16'h0080) begin \n      binary_out = 7; \n     end  if (encoder_in == 16'h0100) begin \n      binary_out = 8; \n     end  if (encoder_in == 16'h0200) begin \n      binary_out = 9; \n     end if (encoder_in == 16'h0400) begin \n      binary_out = 10; \n     end  if (encoder_in == 16'h0800) begin \n      binary_out = 11; \n     end  if (encoder_in == 16'h1000) begin\n      binary_out = 12; \n     end  if (encoder_in == 16'h2000) begin \n      binary_out = 13;\n     end  if (encoder_in == 16'h4000) begin \n      binary_out = 14; \n     end if (encoder_in == 16'h8000) begin \n      binary_out = 15; \n     end\n  end\nend\n      \nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/encoder_using_case.v", "filename": "encoder_using_case.v", "prompt": "Write Verilog code for Encoder Using Case.", "verilog_code": "//-----------------------------------------------------\n// Design Name : encoder_using_case\n// File Name   : encoder_using_case.v\n// Function    : Encoder using Case\n// Coder       : Deepak Kumar Tala\n//-----------------------------------------------------\nmodule encoder_using_case(\nbinary_out , //  4 bit binary Output\nencoder_in , //  16-bit Input\nenable       //  Enable for the encoder\n);\noutput [3:0] binary_out  ;\ninput  enable ; \ninput [15:0] encoder_in ; \n     \nreg [3:0] binary_out ;\n      \nalways @ (enable or encoder_in)\nbegin\n  binary_out = 0;\n  if (enable) begin\n    case (encoder_in) \n      16'h0002 : binary_out = 1; \n      16'h0004 : binary_out = 2; \n      16'h0008 : binary_out = 3; \n      16'h0010 : binary_out = 4;\n      16'h0020 : binary_out = 5; \n      16'h0040 : binary_out = 6; \n      16'h0080 : binary_out = 7; \n      16'h0100 : binary_out = 8;\n      16'h0200 : binary_out = 9;\n      16'h0400 : binary_out = 10; \n      16'h0800 : binary_out = 11; \n      16'h1000 : binary_out = 12; \n      16'h2000 : binary_out = 13; \n      16'h4000 : binary_out = 14; \n      16'h8000 : binary_out = 15; \n   endcase\n  end\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/latch_udp.v", "filename": "latch_udp.v", "prompt": "Write Verilog code for Latch Udp.", "verilog_code": "primitive latch_udp(q, clock, data) ;\noutput q; reg q ;\ninput clock, data;\ntable\n  // clock data   q   q+ \n      0    1    : ? : 1 ;\n      0    0    : ? : 0 ;\n      1    ?    : ? : - ; // - = no change\nendtable\nendprimitive", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/dlatch_reset.v", "filename": "dlatch_reset.v", "prompt": "Write Verilog code for Dlatch Reset.", "verilog_code": "//-----------------------------------------------------\n// Design Name : dlatch_reset\n// File Name   : dlatch_reset.v\n// Function    : DLATCH async reset\n// Coder       : Deepak Kumar Tala\n//-----------------------------------------------------\nmodule dlatch_reset (\ndata   , // Data Input\nen     , // LatchInput\nreset  , // Reset input\nq        // Q output\n);\n//-----------Input Ports---------------\ninput data, en, reset ; \n\n//-----------Output Ports---------------\noutput q;\n\n//------------Internal Variables--------\nreg q;\n\n//-------------Code Starts Here---------\nalways @ ( en or reset or data)\nif (~reset) begin\n  q <= 1'b0;\nend else if (en) begin\n  q <= data;\nend\n\nendmodule //End Of Module dlatch_reset", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/up_counter.v", "filename": "up_counter.v", "prompt": "Write Verilog code for Up Counter.", "verilog_code": "//-----------------------------------------------------\n// Design Name : up_counter\n// File Name   : up_counter.v\n// Function    : Up counter\n// Coder     : Deepak\n//-----------------------------------------------------\nmodule up_counter    (\nout     ,  // Output of the counter\nenable  ,  // enable for counter\nclk     ,  // clock Input\nreset      // reset Input\n);\n//----------Output Ports--------------\n    output [7:0] out;\n//------------Input Ports--------------\n     input enable, clk, reset;\n//------------Internal Variables--------\n    reg [7:0] out;\n//-------------Code Starts Here-------\nalways @(posedge clk)\nif (reset) begin\n  out <= 8'b0 ;\nend else if (enable) begin\n  out <= out + 1;\nend\n\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/nand_switch.v", "filename": "nand_switch.v", "prompt": "Write Verilog code for Nand Switch.", "verilog_code": "module nand_switch(a,b,out);\ninput a,b;\noutput out;\n\nsupply0 vss;\nsupply1 vdd;\nwire net1;\n\npmos p1 (vdd,out,a);\npmos p2 (vdd,out,b);\nnmos n1 (vss,net1,a);\nnmos n2 (net1,out,b);\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/xor_switch.v", "filename": "xor_switch.v", "prompt": "Write Verilog code for Xor Switch.", "verilog_code": "module nor2_switch (a,b,y);\ninput a, b;\noutput y;\n\nsupply1 power;\nsupply0 ground;\n\nwire  connect;\n\nnmos (y,ground,a);\nnmos (y,ground,b);\npmos (y,connect,b);\npmos (power,connect,a);\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/not_switch.v", "filename": "not_switch.v", "prompt": "Write Verilog code for Not Switch.", "verilog_code": "//-----------------------------------------------------\n// Design Name : not_switch\n// File Name   : not_switch.v\n// Function    : NOT Gate Using Switch Primitives\n// Coder       : Deepak Kumar Tala\n//-----------------------------------------------------\nmodule not_switch (out, in);\n   output  out;               \n   input   in;                \n   \n   supply1 power;             \n   supply0 ground;            \n   \n   pmos (out, power, in);     \n   nmos (out, ground, in);    \n   \nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/d_ff_gates.v", "filename": "d_ff_gates.v", "prompt": "Write Verilog code for D Ff Gates.", "verilog_code": "module d_ff_gates(d,clk,q,q_bar);\ninput d,clk;\noutput q, q_bar;\n\nwire n1,n2,n3,q_bar_n;\nwire cn,dn,n4,n5,n6;\n\n// First Latch\nnot (n1,d);\n\nnand (n2,d,clk);\nnand (n3,n1,clk);\n\nnand (dn,q_bar_n,n2);\nnand (q_bar_n,dn,n3);\n\n// Second Latch\nnot (cn,clk);\n\nnot (n4,dn);\n\nnand (n5,dn,cn);\nnand (n6,n4,cn);\n\nnand (q,q_bar,n5);\nnand (q_bar,q,n6);\n\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/or2_input.v", "filename": "or2_input.v", "prompt": "Write Verilog code for Or2 Input.", "verilog_code": "//-----------------------------------------------------\n// Design Name : or2_input\n// File Name   : or2_input.v\n// Function    : 2 Input OR Gate Using UDP\n// Coder       : Deepak Kumar Tala\n//-----------------------------------------------------\nprimitive or2_input (c,a,b);\n  output c;\n  input a,b;\n  table\n    //a b : c\n    1 ? : 1;\n    ? 1 : 1;\n    0 0 : 0;\n    0 x : x;\n    x 0 : x;\n  endtable\nendprimitive", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/xor2_input.v", "filename": "xor2_input.v", "prompt": "Write Verilog code for Xor2 Input.", "verilog_code": "primitive xor2_input (c,a,b);\n  output c;\n  input a,b;\n  table\n     0 0 : 0;\n     0 1 : 1;\n     1 0 : 1;\n     1 1 : 0;\n     x 1 : x;\n     1 x : x;\n     x 0 : x;\n     0 x : x;\n     x x : x;\n  endtable\nendprimitive", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/decoder_using_case.v", "filename": "decoder_using_case.v", "prompt": "Write Verilog code for Decoder Using Case.", "verilog_code": "//-----------------------------------------------------\n// Design Name : decoder_using_case\n// File Name   : decoder_using_case.v\n// Function    : decoder using case\n// Coder       : Deepak Kumar Tala\n//-----------------------------------------------------\nmodule decoder_using_case (\nbinary_in   , //  4 bit binary input\ndecoder_out , //  16-bit  out\nenable        //  Enable for the decoder\n);\ninput [3:0] binary_in  ;\ninput  enable ;\noutput [15:0] decoder_out ;\n\nreg [15:0] decoder_out ;\n\nalways @ (enable or binary_in)\nbegin\n  decoder_out = 0;\n  if (enable) begin\n    case (binary_in)\n      4'h0 : decoder_out = 16'h0001;\n      4'h1 : decoder_out = 16'h0002;\n      4'h2 : decoder_out = 16'h0004;\n      4'h3 : decoder_out = 16'h0008;\n      4'h4 : decoder_out = 16'h0010;\n      4'h5 : decoder_out = 16'h0020;\n      4'h6 : decoder_out = 16'h0040;\n      4'h7 : decoder_out = 16'h0080;\n      4'h8 : decoder_out = 16'h0100;\n      4'h9 : decoder_out = 16'h0200;\n      4'hA : decoder_out = 16'h0400;\n      4'hB : decoder_out = 16'h0800;\n      4'hC : decoder_out = 16'h1000;\n      4'hD : decoder_out = 16'h2000;\n      4'hE : decoder_out = 16'h4000;\n      4'hF : decoder_out = 16'h8000;\n    endcase\n  end\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/decoder_using_assign.v", "filename": "decoder_using_assign.v", "prompt": "Write Verilog code for Decoder Using Assign.", "verilog_code": "//-----------------------------------------------------\n// Design Name : decoder_using_assign\n// File Name   : decoder_using_assign.v\n// Function    : decoder using assign\n// Coder       : Deepak Kumar Tala\n//-----------------------------------------------------\nmodule decoder_using_assign (\nbinary_in   , //  4 bit binary input\ndecoder_out , //  16-bit out \nenable        //  Enable for the decoder\n);\ninput [3:0] binary_in  ;\ninput  enable ; \noutput [15:0] decoder_out ; \n        \nwire [15:0] decoder_out ; \n\nassign decoder_out = (enable) ? (1 << binary_in) : 16'b0 ;\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/t_gate_switch.v", "filename": "t_gate_switch.v", "prompt": "Write Verilog code for T Gate Switch.", "verilog_code": "module t_gate_switch (L,R,nC,C);\r\n inout L;\r\n inout R;\r\n input nC;\r\n input C;\r\n\r\n //Syntax: keyword unique_name (drain. source, gate);\r\n pmos p1 (L,R,nC);\r\n nmos p2 (L,R,C);\r\n\r\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/full_adder_gates.v", "filename": "full_adder_gates.v", "prompt": "Write Verilog code for Full Adder Gates.", "verilog_code": "//-----------------------------------------------------\n// Design Name : full_adder_gates\n// File Name   : full_adder_gates.v\n// Function    : Full Adder Using Gates\n// Coder       : Deepak Kumar Tala\n//-----------------------------------------------------\nmodule full_adder_gates(x,y,z,sum,carry);\ninput x,y,z;\noutput sum,carry;\nwire and1,and2,and3,sum1;\n\nand U_and1 (and1,x,y),\n    U_and2 (and2,x,z),\n    U_and3 (and3,y,z);\nor  U_or   (carry,and1,and2,and3);\nxor U_sum (sum,x,y,z);\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/half_adder_gates.v", "filename": "half_adder_gates.v", "prompt": "Write Verilog code for Half Adder Gates.", "verilog_code": "//-----------------------------------------------------\n// Design Name : half_adder_gates\n// File Name   : half_adder_gates.v\n// Function    : CCITT Serial CRC\n// Coder       : Deepak Kumar Tala\n//-----------------------------------------------------\nmodule half_adder_gates(x,y,sum,carry);\ninput x,y;\noutput sum,carry;\n\nand U_carry (carry,x,y);\nxor U_sum (sum,x,y);\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/dff_async_reset.v", "filename": "dff_async_reset.v", "prompt": "Write Verilog code for Dff Async Reset.", "verilog_code": "//-----------------------------------------------------\n// Design Name : dff_async_reset\n// File Name   : dff_async_reset.v\n// Function    : D flip-flop async reset\n// Coder       : Deepak Kumar Tala\n//-----------------------------------------------------\nmodule dff_async_reset (\ndata  , // Data Input\nclk    , // Clock Input\nreset , // Reset input \nq         // Q output\n);\n//-----------Input Ports---------------\ninput data, clk, reset ; \n\n//-----------Output Ports---------------\noutput q;\n\n//------------Internal Variables--------\nreg q;\n\n//-------------Code Starts Here---------\nalways @ ( posedge clk or negedge reset)\nif (~reset) begin\n  q <= 1'b0;\nend  else begin\n  q <= data;\nend\n\nendmodule //End Of Module dff_async_reset", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/parity_using_bitwise.v", "filename": "parity_using_bitwise.v", "prompt": "Write Verilog code for Parity Using Bitwise.", "verilog_code": "//-----------------------------------------------------\n// Design Name : parity_using_bitwise\n// File Name   : parity_using_bitwise.v\n// Function    : Parity using bitwise xor\n// Coder       : Deepak Kumar Tala\n//-----------------------------------------------------\nmodule parity_using_bitwise (\ndata_in    , //  8 bit data in\nparity_out   //  1 bit parity out\n);\noutput  parity_out ;\ninput [7:0] data_in ; \n     \nassign parity_out = ^data_in; \n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/hdl_models/cam.v", "filename": "cam.v", "prompt": "Write Verilog code for Cam.", "verilog_code": "//-----------------------------------------------------\n// Design Name : cam\n// File Name   : cam.v\n// Function    : CAM\n// Coder       : Deepak Kumar Tala\n//-----------------------------------------------------\nmodule cam (\nclk         , // Cam clock\ncam_enable  , // Cam enable\ncam_data_in , // Cam data to match\ncam_hit_out , // Cam match has happened\ncam_addr_out  // Cam output address \n);\n\nparameter ADDR_WIDTH  = 8;\nparameter DEPTH       = 1 << ADDR_WIDTH;\n//------------Input Ports--------------\ninput                    clk;      \ninput                    cam_enable;   \ninput  [DEPTH-1:0]       cam_data_in;  \n//----------Output Ports--------------\noutput                   cam_hit_out;  \noutput [ADDR_WIDTH-1:0]  cam_addr_out;  \n//------------Internal Variables--------\nreg [ADDR_WIDTH-1:0]  cam_addr_out;\nreg                   cam_hit_out;\nreg [ADDR_WIDTH-1:0]  cam_addr_combo;\nreg                   cam_hit_combo;\nreg                   found_match;\ninteger               i;\n//-------------Code Starts Here-------\nalways @(cam_data_in) begin\n  cam_addr_combo   = {ADDR_WIDTH{1'b0}};\n  found_match      = 1'b0;\n  cam_hit_combo    = 1'b0;\n  for (i=0; i<DEPTH; i=i+1) begin\n    if (cam_data_in[i] && !found_match) begin\n      found_match     = 1'b1;\n      cam_hit_combo   = 1'b1;\n      cam_addr_combo  = i;\n    end else begin\n      found_match     = found_match;\n      cam_hit_combo   = cam_hit_combo;\n      cam_addr_combo  = cam_addr_combo;\n    end\n  end\nend\n\n// Register the outputs \nalways @(posedge clk) begin\n  if (cam_enable) begin\n    cam_hit_out  <=  cam_hit_combo;\n    cam_addr_out <=  cam_addr_combo;\n  end else begin\n    cam_hit_out  <=  1'b0;\n    cam_addr_out <=  {ADDR_WIDTH{1'b0}};\n  end\nend\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
{"url": "https://www.asic-world.com/code/vera/sample_if.v", "filename": "sample_if.v", "prompt": "Write Verilog code for Sample If.", "verilog_code": "module sample_if_verilog ();\n// Internal variables\nreg [3:0] counter;\nreg       clk;\nwire      rst;\nwire      counter_en;\nwire      data;\nwire      ddr_data_in;\nwire      ddr_data_out;\n\nassign data = (counter[2]) ? counter[0] : counter[1];\nassign ddr_data_in = (clk) ? counter[0] : counter[1];\n\n// Connect the program here\ninterface_ex vshell(\n .SystemClock            (clk),\n .\\sample_if.clock       (clk),\n .\\sample_if.reset       (rst),\n .\\sample_if.enable      (counter_en),\n .\\sample_if.cout        (counter),\n .\\sample_if.data        (data),\n .\\sample_if.ddr_data_in (ddr_data_in)\n);\n// Init all the variables\ninitial begin\n  clk = 0;\nend\n// Clock generator\nalways #1 clk = ~clk;\n// Counter code\nalways @ (posedge clk)\n  if (rst) counter <= 0;\n  else if (counter_en) counter <= counter + 1;\n\nendmodule", "meta_tags": {"source": "asic-world", "category": "auto-crawled"}}
